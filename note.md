# BIENVENU DANS LE PROJET DE EGO TRANSFERT

## ETAPE 1: CONFIGURATION DE BASE
### Initialisation projet avec prisma
```javascript
npx prisma init
```
**Attention**ðŸš©
assure toi de pouvoir avoir la version nodejs superieur a 16.


### Initialisation projet typecript
```javascript
npm init -y
npm install typescript ts-node @types/node --save-dev
```

### Initialisation typescript
```javascript
npx tsc --init
```
### Install le client prisma pour les dependance en dev dans le projet
```javascript
npm install prisma --save-dev
```
### installation de express
```javascript
npm install express
npm install @types/express --save-dev
```
### Installation Nodemon
```javascript
npm install nodemon --save-dev
```
```javascript
npm install @prisma/client
```
```javascript
npm i express dotenv
```



## ETAPE 2: configuration dans le package.json
De base nous avons
```javascript
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
},
```

Ensuite nous passons a ceci
```javascript
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/index.ts",
    "migrate": "prisma migrate dev"
  },
```
## ETAPE 2: CONNECTION A LA BASE DE DONNEE MONGODB

Dans le `schema.prisma` On a:
```javascript
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

Il doit maintenant etre change en:
```javascript
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}
```

## ETAPE 2: CREATION DE L'ARCHITECTURE DE BASE DANS LE INDEX.TS

```javascript
const express = require('express');
const dotenv = require('dotenv');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
    console.log(`Server is running on port http://localhost:${PORT}`);
});
```
```javascript
1- configuration installation
2- simple connextion server in index.ts
3- connection to ddatabase( updrage index,ts)
4- Prisma generate
5- message de connexion correct a la database
6- simple routes dans le index et test

partie 2

7- creation des fichier routes/users/userRoutes.ts et test

```


### PRISMA GENERATE

```javascript
npx prisma generate
```
**8- inscription**
lorsque l'on fait un 
```javascript
console.log(req.body)
```
nous obtenons une reponse vide. Pour avoir qu'elles sont les elements qui pourront etre qui vont etre pris en compte pour la creation d'un utilisateur on fait comme ceci

**Code v1: Simple creation**

* Register
```javascript
export const userRegisterCtrl = async (req: Request, res: Response) => {
    const { firstname, lastname, email, phone, password } = req.body
    try {
        res.json({
            status: 'success',
            message: 'Inscription reussie'
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```


**Code v2: seconde avance**

* Register
```javascript
export const userRegisterCtrl = async (req: Request, res: Response) => {
    const { firstname, lastname, email, phone, password } = req.body
    console.log('Received data:', { firstname, lastname, email, phone, password });
    try {
        // verifions si l'email exist deja
        const emailFound = await prisma.user.findUnique({
            where: { 
                email: email 
            }
        });
        if (emailFound) {
            return res.json({
                message: 'email existe'
            })
        }
        // VÃ©rifions si le numÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ 
        const phoneFound = await prisma.user.findUnique({
            where: {
                phone: phone
            }
        });


        if (phoneFound) {
            return res.json({
                message: 'phone existe'
            })
        }
        // cryptage du mot de passe
        // creation d'un utilisateur
        const newUser = await prisma.user.create({
            data: {
                firstname,
                lastname,
                email,
                phone,
                password
            }
        })
        res.json({
            status: 'success',
            data: newUser
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}  
```

* Login
```javascript
export const userLoginCtrl = async (req: Request, res: Response) => {
    const { email, password } = req.body
    try {
        const user = await prisma.user.findUnique({
            where: {
                email
            }
        })
        if (!user) {
            return res.json({
                status: 'fail',
                message: 'email incorrect'
            })
        }
        if (user.password !== password) {
            return res.json({
                status: 'fail',
                message: 'mot de passe incorrect'
            })
        }
        res.json({
            status: 'success',
            message: 'Connexion reussie'
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```

* GET ONE USER
```javascript
export const getOneUserCtrl = async (req: Request, res: Response) => {
    const { id } = req.params;
    console.log('Received data:', { id });
    try {
        const user = await prisma.user.findUnique({
            where: {
                id: id
            }
        });
        res.json({
            status: 'success',
            data: {
                firstane: user?.firstname,
                lastname: user?.lastname,
                email: user?.email,
                phone: user?.phone,
                role: user?.role,
                isSuperuser: user?.isSuperuser,
                isblocked: user?.isBlocked
            }
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```

* Get all
```javascript
export const getAllUserCtrl = async (req: Request, res: Response) => {
    try {
        const allUser = await prisma.user.findMany();
        res.json({
            status: 'success',
            data: allUser
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```

* Updata
```javascript
export const updateUserCtrl = async (req: Request, res: Response) => {
    const userId = req.params.id
    const { firstname, lastname, password, email } = req.body
    if (!firstname && !lastname && !email && !password) {
        return res.json({
            status: 'fail',
            message: 'aucune donnee a mettre a jour'
        });
    }
    try {
        // verifier si le user existe
        const user = await prisma.user.findUnique({
            where: {
                id: userId
            }
        });
        if (!user) {
            return res.json({
                status: 'fail',
                message: 'utilisateur non trouve'
            });
        }

        // mettre a jour l'utilisateur
        const updateUser = await prisma.user.update({
            where: {
                id: userId
            },
            data: {
                ...(firstname && { firstname }),
                ...(lastname && { lastname }),
                ...(email && { email }),
                ...(password && { password }),
            }
        });
        console.log('mise a jour reussi')
        res.json({
            status: 'success',
            data: updateUser
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```

```javascript
export const deleteUserCtrl = async (req: Request, res: Response) => {
    const userId = req.params.id
    try {
        await prisma.user.delete({
            where: {
                id: userId
            }
        })
        res.json({
            status: 'success',
            message: 'suppression reussie'
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```


```javascript
import { Router, Request, Response } from 'express';
import {
    getOneUserCtrl,
    getAllUserCtrl,
    updateUserCtrl,
    deleteUserCtrl,
    logoutCtrl,
    updatePasswordCtrl,
} from '../../controllers/userCtrl';

const router = Router();

router.get('/profile/:id', getOneUserCtrl);

router.get('/all/', getAllUserCtrl);

router.put('/update/:id', updateUserCtrl);

router.delete('/delete/:id', deleteUserCtrl)
// updatePasswordCtrl
router.put('/update-password/', updatePasswordCtrl)

router.get('/logout/', logoutCtrl);

export default router;
```


ancien

```javascript
export const getOneUserCtrl = async (req: Request, res: Response) => {
    const { id } = req.params;
    console.log('Received data:', { id });
    try {
        const user = await prisma.user.findUnique({
            where: {
                id: id
            }
        });
        res.json({
            status: 'success',
            data: {
                firstname: user?.firstname,
                lastname: user?.lastname,
                email: user?.email,
                role: user?.role,
                isSuperuser: user?.isSuperuser,
                isblocked: user?.isBlocked
            }
        })
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        })
    }
}
```

nouveau
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
**9- authentification et authorisation**

```javascript
npm install @prisma/client bcrypt jsonwebtoken uuid
```


Je comprends mieux maintenant. Vous avez raison, rechercher l'utilisateur par son id n'est pas la bonne approche dans ce cas. Puisque vous souhaitez vÃ©rifier si le numÃ©ro de tÃ©lÃ©phone est dÃ©jÃ  utilisÃ© par un autre utilisateur lors de l'inscription, vous devez effectuer une recherche directe dans la base de donnÃ©es en utilisant le numÃ©ro de tÃ©lÃ©phone comme critÃ¨re de recherche.

Voici comment vous pouvez le faire :

```typescript
export const userRegisterCtrl = async (req: Request, res: Response) => {
    const { firstname, lastname, email, phone, password } = req.body;

    try {
        // VÃ©rifions si l'email existe dÃ©jÃ 
        const emailFound = await prisma.user.findUnique({
            where: { email: email }
        });

        if (emailFound) {
            return res.json({
                status: 'fail',
                message: 'Email existe dÃ©jÃ '
            });
        }

        // VÃ©rifions si le numÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ 
        const phoneFound = await prisma.user.findUnique({
            where: { phone: phone }
        });

        if (phoneFound) {
            return res.json({
                status: 'fail',
                message: 'NumÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ '
            });
        }

        // Cryptage du mot de passe
        const hashedPassword = await bcrypt.hash(password, 10);

        // CrÃ©ation d'un utilisateur
        const newUser = await prisma.user.create({
            data: {
                firstname,
                lastname,
                email,
                phone,
                password: hashedPassword
            }
        });

        res.json({
            status: 'success',
            data: newUser
        });
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        });
    }
};
```

Dans ce code, nous utilisons `prisma.user.findUnique()` pour rechercher un utilisateur par son numÃ©ro de tÃ©lÃ©phone. Si un utilisateur est trouvÃ© avec ce numÃ©ro de tÃ©lÃ©phone, cela signifie que le numÃ©ro est dÃ©jÃ  utilisÃ© par un autre utilisateur, donc nous renvoyons un message d'Ã©chec appropriÃ©. Sinon, nous continuons avec la crÃ©ation de l'utilisateur.

Cette approche est la bonne pour s'assurer que le numÃ©ro de tÃ©lÃ©phone est unique pour chaque utilisateur lors de l'inscription. J'espÃ¨re que cela rÃ©pond Ã  votre question ! N'hÃ©sitez pas si vous avez d'autres interrogations.


Bien sÃ»r, voici un exemple de code pour mettre en Å“uvre l'authentification JWT avec Prisma en TypeScript, en utilisant Ã  la fois un jeton d'accÃ¨s (access token) et un jeton de rafraÃ®chissement (refresh token) :

Tout d'abord, vous devez installer les dÃ©pendances nÃ©cessaires :

```bash
npm install jsonwebtoken bcryptjs
```

Ensuite, voici le code :

```typescript
// userCtrl.ts

import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();

const JWT_SECRET = 'your_secret_key';
const ACCESS_TOKEN_EXPIRATION = '1h';
const REFRESH_TOKEN_EXPIRATION = '7d';

export const registerUser = async (req: Request, res: Response) => {
    try {
        const { email, password } = req.body;

        // VÃ©rifier si l'utilisateur existe dÃ©jÃ 
        const existingUser = await prisma.user.findUnique({
            where: { email: email }
        });

        if (existingUser) {
            return res.status(400).json({ message: 'Email already exists' });
        }

        // Hasher le mot de passe
        const hashedPassword = await bcrypt.hash(password, 10);

        // CrÃ©er l'utilisateur
        const newUser = await prisma.user.create({
            data: {
                email,
                password: hashedPassword
            }
        });

        res.status(201).json({ message: 'User created successfully' });
    } catch (error) {
        console.error('Error registering user:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
};

export const loginUser = async (req: Request, res: Response) => {
    try {
        const { email, password } = req.body;

        // Rechercher l'utilisateur par email
        const user = await prisma.user.findUnique({
            where: { email: email }
        });

        // VÃ©rifier si l'utilisateur existe
        if (!user) {
            return res.status(401).json({ message: 'Invalid email or password' });
        }

        // VÃ©rifier le mot de passe
        const passwordMatch = await bcrypt.compare(password, user.password);

        if (!passwordMatch) {
            return res.status(401).json({ message: 'Invalid email or password' });
        }

        // GÃ©nÃ©rer le jeton d'accÃ¨s
        const accessToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: ACCESS_TOKEN_EXPIRATION });

        // GÃ©nÃ©rer le jeton de rafraÃ®chissement
        const refreshToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: REFRESH_TOKEN_EXPIRATION });

        res.json({ accessToken, refreshToken });
    } catch (error) {
        console.error('Error logging in user:', error);
        res.status(500).json({ message: 'Internal server error' });
    }
};
```

Ce code fournit deux endpoints : un pour l'enregistrement d'un nouvel utilisateur (`registerUser`) et un pour la connexion d'un utilisateur existant (`loginUser`). Lorsqu'un utilisateur se connecte avec succÃ¨s, il reÃ§oit Ã  la fois un jeton d'accÃ¨s et un jeton de rafraÃ®chissement.

Assurez-vous de remplacer `'your_secret_key'` par une clÃ© secrÃ¨te sÃ©curisÃ©e dans la variable `JWT_SECRET`. Vous pouvez Ã©galement ajuster les durÃ©es d'expiration des jetons d'accÃ¨s et de rafraÃ®chissement en modifiant les valeurs des constantes `ACCESS_TOKEN_EXPIRATION` et `REFRESH_TOKEN_EXPIRATION`.








Ce code est un contrÃ´leur qui gÃ¨re l'action de visualisation du profil d'un utilisateur par un autre utilisateur. Voici une explication Ã©tape par Ã©tape du code :

1. **Recherche de l'utilisateur original** : Le contrÃ´leur commence par rechercher l'utilisateur original (dont le profil est visualisÃ©) en utilisant l'identifiant passÃ© dans les paramÃ¨tres de la requÃªte (`req.params.id`). Il utilise `User.findById` pour rechercher cet utilisateur dans la base de donnÃ©es.

2. **Recherche de l'utilisateur qui visualise** : Ensuite, le contrÃ´leur recherche l'utilisateur qui visualise le profil. Il utilise `User.findById` en utilisant `req.userAuth` pour obtenir cet utilisateur. Il est probable que `req.userAuth` soit un middleware prÃ©cÃ©dent qui a extrait l'utilisateur Ã  partir du jeton JWT ou d'autres moyens d'authentification.

3. **VÃ©rification des utilisateurs trouvÃ©s** : Le contrÃ´leur vÃ©rifie si les deux utilisateurs sont trouvÃ©s dans la base de donnÃ©es.

4. **VÃ©rification si l'utilisateur a dÃ©jÃ  Ã©tÃ© visualisÃ©** : Il vÃ©rifie si l'utilisateur qui visualise est dÃ©jÃ  prÃ©sent dans le tableau des "viewers" de l'utilisateur original. Pour cela, il utilise la mÃ©thode `find` sur le tableau `user.viewers`. Il compare l'identifiant de chaque "viewer" avec l'identifiant de l'utilisateur qui visualise.

5. **Ajout de l'utilisateur visualisant** : Si l'utilisateur qui visualise n'a pas dÃ©jÃ  Ã©tÃ© enregistrÃ© comme "viewer", il est ajoutÃ© au tableau des "viewers" de l'utilisateur original en utilisant `user.viewers.push(userWhoView._id)`.

6. **Sauvegarde des modifications** : Les modifications apportÃ©es Ã  l'utilisateur original sont sauvegardÃ©es en appelant `user.save()`.

7. **RÃ©ponse de rÃ©ussite** : Enfin, une rÃ©ponse JSON est renvoyÃ©e indiquant que la visualisation du profil a rÃ©ussi.

Concernant la ligne que vous avez mentionnÃ©e :

```javascript
const isUserAlreadyViewed = user.viewers.find(
    viewer => viewer.toString() === userWhoView._id.toString()
);
```

Cela recherche dans le tableau `user.viewers` si l'identifiant de l'utilisateur qui visualise (`userWhoView._id`) est dÃ©jÃ  prÃ©sent. Il utilise `toString()` pour comparer les identifiants sous forme de chaÃ®nes de caractÃ¨res. Si l'utilisateur est dÃ©jÃ  prÃ©sent dans le tableau, `isUserAlreadyViewed` sera dÃ©fini sur cet utilisateur, sinon il sera `undefined`.












L'erreur indique que la valeur de `phoneNumber` est `null` dans votre requÃªte. Assurez-vous que le champ `phoneNumber` est inclus dans le corps de la requÃªte (request body) et qu'il n'est pas `null`.

### Solution :

1. **Validation de la RequÃªte** : Ajoutez une validation pour vÃ©rifier que tous les champs requis sont prÃ©sents et ne sont pas `null`.
2. **Utilisation d'OpÃ©rateurs Optionnels** : Vous pouvez utiliser des opÃ©rateurs optionnels pour mettre Ã  jour uniquement les champs fournis.

### Mise Ã  Jour du Code avec Validation :

```typescript
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const updateUserCtrl = async (req: Request, res: Response) => {
    const userId = req.params.id;
    const { firstname, lastname, email, phoneNumber, password } = req.body;

    // Validation des champs requis
    if (!userId) {
        return res.status(400).json({ status: 'fail', message: 'User ID is required' });
    }
    if (!firstname && !lastname && !email && !phoneNumber && !password) {
        return res.status(400).json({ status: 'fail', message: 'At least one field is required to update' });
    }

    try {
        // VÃ©rifier si l'utilisateur existe
        const user = await prisma.user.findUnique({
            where: {
                id: userId,
            },
        });

        if (!user) {
            return res.status(404).json({
                status: 'fail',
                message: 'Utilisateur non trouvÃ©',
            });
        }

        // Mettre Ã  jour l'utilisateur avec des champs optionnels
        const updatedUser = await prisma.user.update({
            where: {
                id: userId,
            },
            data: {
                ...(firstname && { firstname }),
                ...(lastname && { lastname }),
                ...(email && { email }),
                ...(phoneNumber && { phone: phoneNumber }),
                ...(password && { password }),
            },
        });

        res.json({
            status: 'success',
            data: updatedUser,
        });
    } catch (err) {
        const error = err as Error;
        res.status(500).json({
            status: 'fail',
            message: error.message,
        });
    }
};
```

### Explications :

1. **Validation des Champs Requis** :
   - VÃ©rifiez que `userId` est fourni.
   - VÃ©rifiez qu'au moins un champ (firstname, lastname, email, phoneNumber, password) est fourni dans le corps de la requÃªte.

2. **Utilisation d'OpÃ©rateurs Optionnels** :
   - Utilisez l'opÃ©rateur de dÃ©composition `...` pour ajouter des champs uniquement s'ils ne sont pas `null` ou `undefined`. Par exemple, `...(firstname && { firstname })` ajoute `firstname` au champ `data` seulement si `firstname` est une valeur vÃ©ridique (non `null` ou `undefined`).

Cela permet de mettre Ã  jour seulement les champs fournis et d'Ã©viter des erreurs si certains champs ne sont pas inclus dans la requÃªte.


L'erreur indique que le champ `phoneNumber` est dÃ©fini comme non nullable dans votre schÃ©ma de base de donnÃ©es, mais la valeur fournie est `null`, ce qui est incompatible.

Il semble que votre application s'attend Ã  ce que le champ `phoneNumber` ne soit pas `null`, mais les donnÃ©es que vous envoyez contiennent probablement une valeur `null` pour ce champ.

Pour rÃ©soudre ce problÃ¨me, vous pouvez effectuer les actions suivantes :

1. VÃ©rifiez le contenu de la requÃªte que vous envoyez pour vous assurer que le champ `phoneNumber` est dÃ©fini et qu'il contient une valeur non nulle.

2. Si le champ `phoneNumber` peut Ãªtre facultatif, vous pouvez le modifier dans votre schÃ©ma Prisma en le dÃ©clarant comme nullable (`String?` au lieu de `String`).

3. Assurez-vous que la clÃ© correspondant au champ `phoneNumber` dans le corps de la requÃªte JSON est correctement dÃ©finie et ne contient pas de valeur `null`.

Une fois que vous avez vÃ©rifiÃ© et Ã©ventuellement corrigÃ© ces points, rÃ©essayez d'envoyer la requÃªte et voyez si l'erreur persiste. Si vous rencontrez toujours des problÃ¨mes, assurez-vous de fournir plus de dÃ©tails sur la structure de votre requÃªte et de votre schÃ©ma de base de donnÃ©es pour une assistance plus prÃ©cise.







L'erreur indique que Prisma reÃ§oit une valeur `null` pour le champ `phoneNumber`, mais ce champ est dÃ©fini comme non nullable dans votre schÃ©ma. 

Pour rÃ©soudre ce problÃ¨me, vous pouvez suivre ces Ã©tapes :

1. **Corriger la clÃ© `phoneNumber`** :
   Assurez-vous que la clÃ© `phoneNumber` dans votre schÃ©ma correspond bien Ã  la clÃ© que vous utilisez dans votre code. Si votre schÃ©ma utilise `phone` et non `phoneNumber`, modifiez votre code pour utiliser la bonne clÃ©.

2. **VÃ©rifier la structure de la requÃªte** :
   Assurez-vous que toutes les clÃ©s de la requÃªte HTTP sont bien dÃ©finies et correspondent Ã  ce qui est attendu dans votre base de donnÃ©es.

Voici un exemple mis Ã  jour pour reflÃ©ter correctement les noms de champs et Ã©viter les erreurs de type null :

### Code mis Ã  jour pour la mise Ã  jour de l'utilisateur

```typescript
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

export const updateUserCtrl = async (req: Request, res: Response) => {
    const userId = req.params.id;
    const { firstname, lastname, email, phone, password } = req.body;

    try {
        // VÃ©rifier si l'utilisateur existe
        const user = await prisma.user.findUnique({
            where: {
                id: userId
            }
        });

        if (!user) {
            return res.json({
                status: 'fail',
                message: 'utilisateur non trouvÃ©'
            });
        }

        // Mettre Ã  jour l'utilisateur
        const updatedUser = await prisma.user.update({
            where: {
                id: userId
            },
            data: {
                firstname,
                lastname,
                email,
                phone,
                password
            },
        });

        res.json({
            status: 'success',
            data: updatedUser
        });
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        });
    }
};
```

### SchÃ©ma Prisma corrigÃ©

Assurez-vous que votre schÃ©ma Prisma est correct et que les champs `phone` et `email` sont dÃ©finis comme nullable si nÃ©cessaire. Voici un exemple :

```prisma
model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  firstname String?
  lastname  String?
  email     String   @unique
  phone     String   @unique
  password  String
  // autres champs...
}
```

### Assurez-vous que les donnÃ©es envoyÃ©es dans la requÃªte ne contiennent pas de `null`

Lorsque vous envoyez une requÃªte pour mettre Ã  jour un utilisateur, assurez-vous que les donnÃ©es ne contiennent pas de valeurs `null` pour des champs qui ne doivent pas l'Ãªtre. Par exemple :

```json
{
  "firstname": "RITA",
  "lastname": "debo",
  "email": "debo@tt.com",
  "phone": "0022892152921",
  "password": "12345"
}
```

### Testez la mise Ã  jour de l'utilisateur

Avec ces corrections, essayez de mettre Ã  jour un utilisateur en envoyant une requÃªte POST/PUT avec les donnÃ©es appropriÃ©es et vÃ©rifiez si l'erreur persiste. Assurez-vous Ã©galement que le champ `phone` est correctement renseignÃ© et n'est pas `null`.



L'erreur indique que Prisma reÃ§oit une valeur `null` pour le champ `phoneNumber`, mais ce champ est dÃ©fini comme non nullable dans votre schÃ©ma. 

Pour rÃ©soudre ce problÃ¨me, vous pouvez suivre ces Ã©tapes :

1. **Corriger la clÃ© `phoneNumber`** :
   Assurez-vous que la clÃ© `phoneNumber` dans votre schÃ©ma correspond bien Ã  la clÃ© que vous utilisez dans votre code. Si votre schÃ©ma utilise `phone` et non `phoneNumber`, modifiez votre code pour utiliser la bonne clÃ©.

2. **VÃ©rifier la structure de la requÃªte** :
   Assurez-vous que toutes les clÃ©s de la requÃªte HTTP sont bien dÃ©finies et correspondent Ã  ce qui est attendu dans votre base de donnÃ©es.

Voici un exemple mis Ã  jour pour reflÃ©ter correctement les noms de champs et Ã©viter les erreurs de type null :

### Code mis Ã  jour pour la mise Ã  jour de l'utilisateur

```typescript
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();

export const updateUserCtrl = async (req: Request, res: Response) => {
    const userId = req.params.id;
    const { firstname, lastname, email, phone, password } = req.body;

    try {
        // VÃ©rifier si l'utilisateur existe
        const user = await prisma.user.findUnique({
            where: {
                id: userId
            }
        });

        if (!user) {
            return res.json({
                status: 'fail',
                message: 'utilisateur non trouvÃ©'
            });
        }

        // Mettre Ã  jour l'utilisateur
        const updatedUser = await prisma.user.update({
            where: {
                id: userId
            },
            data: {
                firstname,
                lastname,
                email,
                phone,
                password
            },
        });

        res.json({
            status: 'success',
            data: updatedUser
        });
    } catch (err) {
        const error = err as Error;
        res.json({
            status: 'fail',
            message: error.message
        });
    }
};
```

### SchÃ©ma Prisma corrigÃ©

Assurez-vous que votre schÃ©ma Prisma est correct et que les champs `phone` et `email` sont dÃ©finis comme nullable si nÃ©cessaire. Voici un exemple :

```prisma
model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  firstname String?
  lastname  String?
  email     String   @unique
  phone     String   @unique
  password  String
  // autres champs...
}
```

### Assurez-vous que les donnÃ©es envoyÃ©es dans la requÃªte ne contiennent pas de `null`

Lorsque vous envoyez une requÃªte pour mettre Ã  jour un utilisateur, assurez-vous que les donnÃ©es ne contiennent pas de valeurs `null` pour des champs qui ne doivent pas l'Ãªtre. Par exemple :

```json
{
  "firstname": "RITA",
  "lastname": "debo",
  "email": "debo@tt.com",
  "phone": "0022892152921",
  "password": "12345"
}
```

### Testez la mise Ã  jour de l'utilisateur

Avec ces corrections, essayez de mettre Ã  jour un utilisateur en envoyant une requÃªte POST/PUT avec les donnÃ©es appropriÃ©es et vÃ©rifiez si l'erreur persiste. Assurez-vous Ã©galement que le champ `phone` est correctement renseignÃ© et n'est pas `null`.




Pour un projet comme le vÃ´tre, qui semble impliquer la gestion des utilisateurs et probablement l'authentification, l'utilisation de tokens et de refresh tokens est une approche courante et sÃ©curisÃ©e. Voici une explication dÃ©taillÃ©e de leur fonctionnement et de leur utilisation.

### Token et Refresh Token

#### 1. Token d'AccÃ¨s (Access Token)
- **Description**: Un access token est un jeton d'authentification Ã  courte durÃ©e de vie. Il est utilisÃ© pour accÃ©der aux ressources protÃ©gÃ©es et pour authentifier les requÃªtes de l'utilisateur.
- **DurÃ©e de vie**: GÃ©nÃ©ralement courte (quelques minutes Ã  quelques heures) pour rÃ©duire le risque en cas de compromission.
- **Stockage**: Il est souvent stockÃ© cÃ´tÃ© client, dans la mÃ©moire ou dans un cookie sÃ©curisÃ© (httpOnly).

#### 2. Refresh Token
- **Description**: Un refresh token est un jeton utilisÃ© pour obtenir un nouveau token d'accÃ¨s sans nÃ©cessiter une nouvelle authentification. Il a une durÃ©e de vie plus longue que l'access token.
- **DurÃ©e de vie**: Plus longue (jours, semaines ou mois).
- **Stockage**: Il doit Ãªtre stockÃ© de maniÃ¨re sÃ©curisÃ©e cÃ´tÃ© client, souvent dans un cookie httpOnly pour rÃ©duire le risque d'accÃ¨s par des scripts malveillants.

### Flux de Travail Typique
1. **Authentification Initiale**:
   - L'utilisateur se connecte avec ses identifiants (par exemple, nom d'utilisateur et mot de passe).
   - Le serveur authentifie l'utilisateur et gÃ©nÃ¨re un access token et un refresh token.
   - Le serveur envoie les tokens au client.

2. **AccÃ¨s aux Ressources**:
   - Le client utilise l'access token pour accÃ©der aux ressources protÃ©gÃ©es.
   - L'access token est envoyÃ© dans l'en-tÃªte `Authorization` de chaque requÃªte HTTP (par exemple, `Authorization: Bearer <access_token>`).

3. **Renouvellement du Token**:
   - Lorsque l'access token expire, le client envoie une requÃªte au serveur avec le refresh token pour obtenir un nouveau access token.
   - Si le refresh token est valide, le serveur gÃ©nÃ¨re un nouveau access token et Ã©ventuellement un nouveau refresh token.
   - Le client utilise le nouveau access token pour les requÃªtes futures.

### SÃ©curisation des Tokens
- **HTTP Only Cookies**: Stocker les tokens dans des cookies HTTP Only pour Ã©viter qu'ils ne soient accessibles via JavaScript.
- **Expiration et RÃ©vocation**: DÃ©finir des durÃ©es d'expiration appropriÃ©es et permettre la rÃ©vocation des tokens en cas de besoin.
- **HTTPS**: Utiliser HTTPS pour chiffrer les communications et protÃ©ger les tokens en transit.
- **Scopes et Permissions**: DÃ©finir des scopes et des permissions pour les tokens afin de limiter les actions qu'un token peut autoriser.

### Exemple de Mise en Å’uvre avec Node.js et Prisma
Voici un exemple simplifiÃ© d'implÃ©mentation des access et refresh tokens avec Node.js et Prisma:

```javascript
// Installation des dÃ©pendances nÃ©cessaires
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const prisma = require('@prisma/client');

const app = express();
app.use(express.json());

// ClÃ©s secrÃ¨tes pour les tokens
const ACCESS_TOKEN_SECRET = 'your-access-token-secret';
const REFRESH_TOKEN_SECRET = 'your-refresh-token-secret';

// Fonction pour gÃ©nÃ©rer les tokens
function generateAccessToken(user) {
    return jwt.sign({ userId: user.id }, ACCESS_TOKEN_SECRET, { expiresIn: '15m' });
}

function generateRefreshToken(user) {
    return jwt.sign({ userId: user.id }, REFRESH_TOKEN_SECRET, { expiresIn: '7d' });
}

// Endpoint de login
app.post('/login', async (req, res) => {
    const { email, password } = req.body;
    const user = await prisma.user.findUnique({ where: { email } });

    if (user && await bcrypt.compare(password, user.password)) {
        const accessToken = generateAccessToken(user);
        const refreshToken = generateRefreshToken(user);
        // Enregistrer ou retourner les tokens selon votre logique
        res.json({ accessToken, refreshToken });
    } else {
        res.status(401).send('Email ou mot de passe incorrect');
    }
});

// Endpoint pour rafraÃ®chir le token
app.post('/token', (req, res) => {
    const { token } = req.body;
    if (!token) return res.sendStatus(401);

    jwt.verify(token, REFRESH_TOKEN_SECRET, (err, user) => {
        if (err) return res.sendStatus(403);
        const accessToken = generateAccessToken({ id: user.userId });
        res.json({ accessToken });
    });
});

// Middleware d'authentification
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (!token) return res.sendStatus(401);

    jwt.verify(token, ACCESS_TOKEN_SECRET, (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
}

// Exemple d'endpoint protÃ©gÃ©
app.get('/protected', authenticateToken, (req, res) => {
    res.send('AccÃ¨s accordÃ© Ã  l\'utilisateur authentifiÃ©');
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

Dans cet exemple, nous avons:
- Un endpoint `/login` pour l'authentification de l'utilisateur et la gÃ©nÃ©ration des tokens.
- Un endpoint `/token` pour renouveler l'access token Ã  l'aide du refresh token.
- Un middleware `authenticateToken` pour protÃ©ger les endpoints en vÃ©rifiant l'access token.

Cette approche amÃ©liore la sÃ©curitÃ© en minimisant l'exposition des tokens et en fournissant un mÃ©canisme pour rafraÃ®chir les tokens sans nÃ©cessiter une nouvelle authentification complÃ¨te.






La fonction `main` est utilisÃ©e principalement comme point d'entrÃ©e pour exÃ©cuter des requÃªtes Prisma et gÃ©rer la connexion Ã  la base de donnÃ©es dans des scripts ou des configurations de dÃ©marrage simples. Dans un projet de dÃ©veloppement backend API plus structurÃ©, comme celui que nous avons dÃ©crit, vous n'avez gÃ©nÃ©ralement pas besoin de cette fonction `main` car les requÃªtes Prisma sont exÃ©cutÃ©es directement dans les contrÃ´leurs et les middlewares.

### Utilisation de `main` dans des Scripts Simples

La fonction `main` est souvent utilisÃ©e dans des scripts simples pour des tests rapides ou des tÃ¢ches spÃ©cifiques. Par exemple, si vous voulez initialiser la base de donnÃ©es avec des donnÃ©es de test, vous pouvez Ã©crire un script comme ceci :

```typescript
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
    await prisma.user.create({
        data: {
            name: 'Alice',
            email: 'alice@example.com'
        }
    });

    const allUsers = await prisma.user.findMany();
    console.log(allUsers);
}

main()
    .catch(async (e) => {
        console.error(e);
        process.exit(1);
    })
    .finally(async () => {
        await prisma.$disconnect();
    });
```

Dans ce contexte, `main` est utile pour encapsuler l'ensemble des opÃ©rations Prisma afin de gÃ©rer correctement les erreurs et assurer la dÃ©connexion de la base de donnÃ©es Ã  la fin du script.

### Utilisation de Prisma dans une API StructurÃ©e

Dans une API structurÃ©e, vous gÃ©rez les requÃªtes Prisma directement dans les contrÃ´leurs et les middlewares. Voici un rappel des diffÃ©rentes parties et leur rÃ´le :

1. **Controllers (`src/controllers/userController.ts`)** :
   - Les contrÃ´leurs contiennent la logique des requÃªtes Prisma.
   - Exemple : rÃ©cupÃ©rer tous les utilisateurs, crÃ©er un nouvel utilisateur, etc.

   ```typescript
   import { Request, Response, NextFunction } from 'express';
   import prisma from '../prisma';

   export const getUsers = async (req: Request, res: Response, next: NextFunction) => {
       try {
           const users = await prisma.user.findMany();
           res.json(users);
       } catch (error) {
           next(error);
       }
   };

   export const createUser = async (req: Request, res: Response, next: NextFunction) => {
       try {
           const { name, email } = req.body;
           const newUser = await prisma.user.create({
               data: { name, email }
           });
           res.status(201).json(newUser);
       } catch (error) {
           next(error);
       }
   };
   ```

2. **Routes (`src/routes/userRoutes.ts`)** :
   - Les routes dÃ©finissent les points d'entrÃ©e de votre API.
   - Exemple : dÃ©finir les routes pour obtenir tous les utilisateurs, crÃ©er un utilisateur, etc.

   ```typescript
   import { Router } from 'express';
   import { getUsers, createUser } from '../controllers/userController';

   const router = Router();

   router.get('/', getUsers);
   router.post('/', createUser);

   export default router;
   ```

3. **Middleware d'Erreur (`src/middlewares/errorHandler.ts`)** :
   - Le middleware d'erreur gÃ¨re les erreurs globales de l'application.

   ```typescript
   import { Request, Response, NextFunction } from 'express';

   const errorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
       console.error(err);
       res.status(500).json({ message: 'Internal Server Error' });
   };

   export default errorHandler;
   ```

4. **Configuration de l'Application (`src/app.ts`)** :
   - Le fichier de configuration de l'application initialise Express, configure les middlewares et dÃ©finit les routes.

   ```typescript
   import express from 'express';
   import userRoutes from './routes/userRoutes';
   import errorHandler from './middlewares/errorHandler';

   const app = express();

   app.use(express.json());
   app.use('/users', userRoutes);
   app.use(errorHandler);

   export default app;
   ```

5. **Point d'EntrÃ©e (`src/index.ts`)** :
   - Le point d'entrÃ©e dÃ©marre le serveur.

   ```typescript
   import app from './app';

   const PORT = process.env.PORT || 3000;

   app.listen(PORT, () => {
       console.log(`Server is running on port ${PORT}`);
   });
   ```

### Conclusion

Dans une application structurÃ©e de type backend API, les opÃ©rations Prisma sont intÃ©grÃ©es directement dans les contrÃ´leurs et les middlewares. La fonction `main` est plus adaptÃ©e pour des scripts isolÃ©s, des tÃ¢ches ponctuelles ou des tests rapides. Dans le cadre d'une API, vous gÃ©rez la connexion Ã  la base de donnÃ©es et les requÃªtes Prisma au niveau des contrÃ´leurs pour une meilleure organisation et maintenabilitÃ© du code.


CrÃ©er un middleware `isLogin` pour vÃ©rifier si un utilisateur est connectÃ© est une excellente idÃ©e. Ce middleware interceptera les requÃªtes entrantes, vÃ©rifiera la validitÃ© du token d'accÃ¨s et permettra l'accÃ¨s aux routes protÃ©gÃ©es uniquement si l'utilisateur est authentifiÃ©.

Voici comment vous pouvez implÃ©menter un middleware `isLogin` dans votre projet Node.js avec Express et Prisma :

### 1. Installer les DÃ©pendances NÃ©cessaires
Assurez-vous d'avoir les packages nÃ©cessaires installÃ©s :
```sh
npm install express jsonwebtoken prisma @prisma/client
```

### 2. CrÃ©er le Middleware `isLogin`
Le middleware vÃ©rifiera la prÃ©sence du token dans les en-tÃªtes de la requÃªte, le validera et ajoutera les informations de l'utilisateur Ã  la requÃªte pour un usage ultÃ©rieur.

```javascript
const jwt = require('jsonwebtoken');

const ACCESS_TOKEN_SECRET = 'your-access-token-secret'; // Remplacez par votre clÃ© secrÃ¨te

// Middleware isLogin
function isLogin(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.sendStatus(401).json({ message: 'Access Token Manquant' });
    }

    jwt.verify(token, ACCESS_TOKEN_SECRET, (err, user) => {
        if (err) {
            return res.sendStatus(403).json({ message: 'Token Invalide' });
        }

        req.user = user; // Ajoute les informations de l'utilisateur Ã  la requÃªte
        next(); // Passe Ã  la prochaine middleware ou route
    });
}

module.exports = isLogin;
```

### 3. Utiliser le Middleware `isLogin` dans vos Routes
IntÃ©grez le middleware dans vos routes protÃ©gÃ©es pour vÃ©rifier que l'utilisateur est connectÃ© avant de permettre l'accÃ¨s.

```javascript
const express = require('express');
const app = express();
const isLogin = require('./middlewares/isLogin'); // Chemin vers votre middleware
const prisma = require('@prisma/client');

app.use(express.json());

// Exemple d'endpoint protÃ©gÃ©
app.get('/protected', isLogin, (req, res) => {
    res.send('AccÃ¨s accordÃ© Ã  l\'utilisateur authentifiÃ©');
});

// Autre exemple avec une route qui retourne les informations de l'utilisateur connectÃ©
app.get('/profile', isLogin, async (req, res) => {
    try {
        const user = await prisma.user.findUnique({ where: { id: req.user.userId } });
        res.json(user);
    } catch (err) {
        res.status(500).json({ message: 'Erreur interne du serveur' });
    }
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

### Explications :
1. **Token d'AccÃ¨s** : Le middleware `isLogin` extrait le token d'accÃ¨s de l'en-tÃªte `Authorization`.
2. **Validation du Token** : Utilisation de `jwt.verify()` pour vÃ©rifier la validitÃ© du token. Si le token est invalide ou absent, le middleware renvoie une rÃ©ponse appropriÃ©e.
3. **Ajout d'Informations Ã  la RequÃªte** : Si le

```javascript
```













# JSONWEBTOKEN





Bien sÃ»r ! Voici un rÃ©sumÃ© des Ã©tapes pour implÃ©menter l'authentification JWT avec Prisma et MongoDB en utilisant TypeScript :

### 1. Configuration initiale
- **Installation des dÃ©pendances :**
  ```bash
  npm install express prisma @prisma/client bcrypt jsonwebtoken body-parser express-validator
  npm install -D typescript @types/express @types/bcrypt @types/jsonwebtoken @types/body-parser @types/express-validator
  ```

- **Configuration de Prisma :**
  ```bash
  npx prisma init
  ```
  Configurez `schema.prisma` pour utiliser MongoDB et dÃ©finissez votre modÃ¨le `User` et `RefreshTokens`.

### 2. Configuration du projet TypeScript
- **Configuration de `tsconfig.json` :**
  ```json
  {
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "outDir": "./dist"
    },
    "include": ["src/**/*"]
  }
  ```

### 3. CrÃ©ation des utilitaires JWT
- **CrÃ©ation de `src/utils/tokenJwt/jwt.ts` :**
  ```typescript
  import jwt from 'jsonwebtoken';
  import { User } from '@prisma/client';

  const ACCESS_TOKEN_SECRET = process.env.ACCESS_TOKEN_SECRET || 'youraccesstokensecret';
  const REFRESH_TOKEN_SECRET = process.env.REFRESH_TOKEN_SECRET || 'yourrefreshtokensecret';

  interface JwtPayload {
    userId: string;
  }

  export const generateAccessToken = (user: User): string => {
    return jwt.sign({ userId: user.id }, ACCESS_TOKEN_SECRET, { expiresIn: '15m' });
  };

  export const generateRefreshToken = (user: User): string => {
    return jwt.sign({ userId: user.id }, REFRESH_TOKEN_SECRET, { expiresIn: '7d' });
  };

  export const verifyToken = (token: string, secret: string): JwtPayload | null => {
    try {
      return jwt.verify(token, secret) as JwtPayload;
    } catch (error) {
      return null;
    }
  };
  ```

### 4. CrÃ©ation des contrÃ´leurs d'authentification
- **CrÃ©ation de `src/controllers/authController.ts` :**
```typescript
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import { generateAccessToken, generateRefreshToken } from '../utils/tokenJwt/jwt';
import { validationResult } from 'express-validator';

const prisma = new PrismaClient();

// Controller pour l'inscription des utilisateurs
export const userRegisterCtrl = async (req: Request, res: Response) => {
    // Validation des entrÃ©es
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    // RÃ©cupÃ©ration des donnÃ©es du corps de la requÃªte
    const { firstname, lastname, email, phoneNumber, password } = req.body;

    try {
        // VÃ©rification de l'existence de l'email
        const emailFound = await prisma.user.findUnique({
            where: { email: email }
        });
        if (emailFound) {
            return res.status(400).json({ message: 'L\'email existe dÃ©jÃ ' });
        }

        // VÃ©rification de l'existence du numÃ©ro de tÃ©lÃ©phone
        const phoneNumberFound = await prisma.user.findUnique({
            where: { phoneNumber: phoneNumber }
        });
        if (phoneNumberFound) {
            return res.status(400).json({ message: 'Le numÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ ' });
        }

        // Cryptage du mot de passe
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        // CrÃ©ation de l'utilisateur dans la base de donnÃ©es
        const newUser = await prisma.user.create({
            data: { firstname, lastname, email, phoneNumber, password: hashedPassword }
        });

        // GÃ©nÃ©ration des tokens JWT
        const accessToken = generateAccessToken(newUser);
        const refreshToken = generateRefreshToken(newUser);

        // Sauvegarde du refresh token dans la base de donnÃ©es
        await prisma.refreshTokens.create({
            data: { hashedToken: refreshToken, userId: newUser.id }
        });

        // RÃ©ponse avec les informations de l'utilisateur et les tokens
        res.json({
            status: 'success',
            data: { user: newUser, accessToken, refreshToken }
        });
    } catch (err) {
        // Gestion des erreurs
        const error = err as Error;
        res.status(500).json({ status: 'fail', message: error.message });
    }
};

// Controller pour la connexion des utilisateurs
export const userLoginCtrl = async (req: Request, res: Response) => {
    // Validation des entrÃ©es
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    // RÃ©cupÃ©ration des donnÃ©es du corps de la requÃªte
    const { email, password } = req.body;
    
    try {
        // VÃ©rification de l'existence de l'utilisateur par email
        const user = await prisma.user.findUnique({
            where: { email: email }
        });
        if (!user) {
            return res.status(400).json({ status: 'fail', message: 'Email incorrect' });
        }

        // VÃ©rification du mot de passe
        const validatePassword = await bcrypt.compare(password, user.password);
        if (!validatePassword) {
            return res.status(400).json({ status: 'fail', message: 'Mot de passe incorrect' });
        }

        // GÃ©nÃ©ration des tokens JWT
        const accessToken = generateAccessToken(user);
        const refreshToken = generateRefreshToken(user);

        // Sauvegarde du refresh token dans la base de donnÃ©es
        await prisma.refreshTokens.create({
            data: { hashedToken: refreshToken, userId: user.id }
        });

        // RÃ©ponse avec les informations de l'utilisateur et les tokens
        res.json({
            status: 'success',
            data: {
                firstname: user.firstname,
                lastname: user.lastname,
                email: user.email,
                role: user.role,
                accessToken,
                refreshToken
            }
        });
    } catch (err) {
        // Gestion des erreurs
        const error = err as Error;
        res.status(500).json({ status: 'fail', message: error.message });
    }
};

  ```

### 5. CrÃ©ation du middleware d'authentification
- **CrÃ©ation de `src/middleware/authMiddleware.ts` :**
  ```typescript
  import { Request, Response, NextFunction } from 'express';
  import { verifyToken } from '../utils/tokenJwt/jwt';

  const ACCESS_TOKEN_SECRET = process.env.ACCESS_TOKEN_SECRET || 'youraccesstokensecret';

  interface JwtPayload {
    userId: string;
  }

  export const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
      return res.status(401).json({ message: 'Token manquant' });
    }

    const decoded = verifyToken(token, ACCESS_TOKEN_SECRET);
    if (!decoded) {
      return res.status(403).json({ message: 'Token non valide' });
    }

    (req as any).userId = decoded.userId;
    next();
  };
  ```

### 6. CrÃ©ation des routes
- **CrÃ©ation de `src/routes/authRoutes.ts` :**
  ```typescript
  import { Router } from 'express';
  import { userRegisterCtrl, userLoginCtrl } from '../controllers/authController';
  import { body } from 'express-validator';

  const router = Router();

  router.post(
    '/register',
    [
      body('email').isEmail().withMessage('Email invalide'),
      body('password').isLength({ min: 6 }).withMessage('Le mot de passe doit contenir au moins 6 caractÃ¨res')
    ],
    userRegisterCtrl
  );

  router.post(
    '/login',
    [
      body('email').isEmail().withMessage('Email invalide'),
      body('password').not().isEmpty().withMessage('Le mot de passe est requis')
    ],
    userLoginCtrl
  );

  export default router;
  ```

- **CrÃ©ation de `src/routes/userRoutes.ts` :**
  ```typescript
  import { Router } from 'express';
  import { getUserProfile } from '../controllers/userController';
  import { authenticateToken } from '../middleware/authMiddleware';

  const router = Router();

  router.get('/profile', authenticateToken, getUserProfile);

  export default router;
  ```

### 7. Configuration du contrÃ´leur de profil utilisateur
- **CrÃ©ation de `src/controllers/userController.ts` :**
  ```typescript
  import { Request, Response } from 'express';
  import { PrismaClient } from '@prisma/client';

  const prisma = new PrismaClient();

  export const getUserProfile = async (req: Request, res: Response) => {
    const userId = (req as any).userId;

    try {
      const user = await prisma.user.findUnique({
        where: { id: userId }
      });

      if (!user) {
        return res.status(404).json({ status: 'fail', message: 'Utilisateur non trouvÃ©' });
      }

      res.json({
        status: 'success',
        data: {
          firstname: user.firstname,
          lastname: user.lastname,
          email: user.email,
          phoneNumber: user.phoneNumber,
          role: user.role
        }
      });
    } catch (err) {
      const error = err as Error;
      res.status(500).json({ status: 'fail', message: error.message });
    }
  };
  ```

###



















Les messages d'erreur de validation sont conÃ§us pour Ãªtre utilisÃ©s par le front-end afin de fournir des feedbacks clairs aux utilisateurs. Lors de la conception d'une API, vous voulez que les messages d'erreur soient facilement comprÃ©hensibles pour que les dÃ©veloppeurs front-end puissent les utiliser pour informer les utilisateurs finaux de ce qui doit Ãªtre corrigÃ©.

Quand vous testez l'API avec des outils comme Postman ou Insomnia, les messages d'erreur de validation apparaÃ®tront dans la rÃ©ponse JSON. Voici un exemple de ce Ã  quoi cela ressemblera :

### Exemple de test avec Postman ou Insomnia

1. **Configuration de la requÃªte :**
    - MÃ©thode : `POST`
    - URL : `http://votre-api.com/register`
    - Body (format JSON) :
      ```json
      {
          "email": "mauvaisformatemail",
          "password": "123"
      }
      ```

2. **ExÃ©cution de la requÃªte :**
    - Si les donnÃ©es envoyÃ©es ne respectent pas les rÃ¨gles de validation, la rÃ©ponse sera comme suit :

      ```json
      {
          "errors": [
              {
                  "msg": "Email invalide",
                  "param": "email",
                  "location": "body"
              },
              {
                  "msg": "Le mot de passe doit contenir au moins 6 caractÃ¨res",
                  "param": "password",
                  "location": "body"
              }
          ]
      }
      ```

### Mise en place des rÃ¨gles de validation avec `express-validator`

Pour s'assurer que les messages d'erreur s'affichent comme prÃ©vu, voici comment vous pouvez mettre en place les rÃ¨gles de validation dans vos routes et contrÃ´leurs.

#### Route d'inscription (`register`)

```typescript
import { body } from 'express-validator';
import express from 'express';
import { userRegisterCtrl } from '../controllers/authController';

const router = express.Router();

router.post('/register', [
    body('email').isEmail().withMessage('Email invalide'),
    body('password').isLength({ min: 6 }).withMessage('Le mot de passe doit contenir au moins 6 caractÃ¨res'),
    body('phoneNumber').isMobilePhone().withMessage('NumÃ©ro de tÃ©lÃ©phone invalide'),
], userRegisterCtrl);

export default router;
```

#### Route de connexion (`login`)

```typescript
import { body } from 'express-validator';
import express from 'express';
import { userLoginCtrl } from '../controllers/authController';

const router = express.Router();

router.post('/login', [
    body('email').isEmail().withMessage('Email invalide'),
    body('password').isLength({ min: 6 }).withMessage('Le mot de passe doit contenir au moins 6 caractÃ¨res'),
], userLoginCtrl);

export default router;
```

#### ContrÃ´leur d'inscription

```typescript
import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import { generateAccessToken, generateRefreshToken } from '../utils/tokenJwt/jwt';
import { validationResult } from 'express-validator';

const prisma = new PrismaClient();

// ContrÃ´leur pour l'inscription des utilisateurs
export const userRegisterCtrl = async (req: Request, res: Response) => {
    // Validation des entrÃ©es
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const { firstname, lastname, email, phoneNumber, password } = req.body;

    try {
        // VÃ©rification de l'existence de l'email
        const emailFound = await prisma.user.findUnique({
            where: { email: email }
        });
        if (emailFound) {
            return res.status(400).json({ message: 'L\'email existe dÃ©jÃ ' });
        }

        // VÃ©rification de l'existence du numÃ©ro de tÃ©lÃ©phone
        const phoneNumberFound = await prisma.user.findUnique({
            where: { phoneNumber: phoneNumber }
        });
        if (phoneNumberFound) {
            return res.status(400).json({ message: 'Le numÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ ' });
        }

        // Cryptage du mot de passe
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        // CrÃ©ation de l'utilisateur
        const newUser = await prisma.user.create({
            data: { firstname, lastname, email, phoneNumber, password: hashedPassword }
        });

        // GÃ©nÃ©ration des tokens JWT
        const accessToken = generateAccessToken(newUser);
        const refreshToken = generateRefreshToken(newUser);

        // Sauvegarde du refresh token dans la base de donnÃ©es
        await prisma.refreshTokens.create({
            data: { hashedToken: refreshToken, userId: newUser.id }
        });

        res.json({
            status: 'success',
            data: { user: newUser, accessToken, refreshToken }
        });
    } catch (err) {
        const error = err as Error;
        res.status(500).json({ status: 'fail', message: error.message });
    }
};

// ContrÃ´leur pour la connexion des utilisateurs
export const userLoginCtrl = async (req: Request, res: Response) => {
    // Validation des entrÃ©es
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    const { email, password } = req.body;
    
    try {
        const user = await prisma.user.findUnique({
            where: { email: email }
        });
        if (!user) {
            return res.status(400).json({ status: 'fail', message: 'Email incorrect' });
        }

        const validatePassword = await bcrypt.compare(password, user.password);
        if (!validatePassword) {
            return res.status(400).json({ status: 'fail', message: 'Mot de passe incorrect' });
        }

        // GÃ©nÃ©ration des tokens JWT
        const accessToken = generateAccessToken(user);
        const refreshToken = generateRefreshToken(user);

        // Sauvegarde du refresh token dans la base de donnÃ©es
        await prisma.refreshTokens.create({
            data: { hashedToken: refreshToken, userId: user.id }
        });

        res.json({
            status: 'success',
            data: {
                firstname: user.firstname,
                lastname: user.lastname,
                email: user.email,
                role: user.role,
                accessToken,
                refreshToken
            }
        });
    } catch (err) {
        const error = err as Error;
        res.status(500).json({ status: 'fail', message: error.message });
    }
};
```

### Explication des Commentaires

Les commentaires insÃ©rÃ©s dans le code expliquent chaque Ã©tape, de la validation des entrÃ©es Ã  la gÃ©nÃ©ration des tokens JWT, ce qui peut vous aider Ã  comprendre ce que fait chaque partie du code et comment les diffÃ©rentes Ã©tapes sont liÃ©es entre elles. Les erreurs de validation seront automatiquement affichÃ©es dans la rÃ©ponse JSON lors des tests avec Postman, Insomnia ou toute autre interface front-end, facilitant ainsi le retour d'information pour les utilisateurs finaux.

















































# ERROR HANDLING



Bien sÃ»r, pour une gestion des erreurs et un formatage cohÃ©rent, il est recommandÃ© d'utiliser un middleware de gestion des erreurs dans Express. Cela permet de centraliser la logique de gestion des erreurs et de garantir que toutes les rÃ©ponses d'erreur ont un format cohÃ©rent.

### Ã‰tapes pour la gestion des erreurs

1. **CrÃ©er un middleware de gestion des erreurs global**
2. **Utiliser le middleware de gestion des erreurs dans votre application Express**
3. **Mettre Ã  jour les contrÃ´leurs pour utiliser une gestion des erreurs cohÃ©rente**

### 1. CrÃ©er un middleware de gestion des erreurs global

CrÃ©ez un fichier `src/middleware/errorMiddleware.ts` pour gÃ©rer les erreurs :

```typescript
import { Request, Response, NextFunction } from 'express';

interface ErrorWithStatus extends Error {
  status?: number;
}

export const errorHandler = (err: ErrorWithStatus, req: Request, res: Response, next: NextFunction) => {
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';

  res.status(status).json({
    status: 'fail',
    message: message,
  });
};
```

### 2. Utiliser le middleware de gestion des erreurs dans votre application Express

Mettez Ã  jour votre fichier `src/server.ts` pour utiliser ce middleware :

```typescript
import express from 'express';
import bodyParser from 'body-parser';
import authRoutes from './routes/authRoutes';
import userRoutes from './routes/userRoutes';
import { errorHandler } from './middleware/errorMiddleware';

const app = express();
app.use(bodyParser.json());

app.use('/auth', authRoutes);
app.use('/user', userRoutes);

// Utilisation du middleware de gestion des erreurs
app.use(errorHandler);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

### 3. Mettre Ã  jour les contrÃ´leurs pour utiliser une gestion des erreurs cohÃ©rente

Pour gÃ©rer les erreurs dans vos contrÃ´leurs et les transmettre au middleware de gestion des erreurs, vous pouvez utiliser `next()` pour passer l'erreur.

#### Exemple : Mise Ã  jour de `authController.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcrypt';
import { generateAccessToken, generateRefreshToken } from '../utils/tokenJwt/jwt';
import { validationResult } from 'express-validator';

const prisma = new PrismaClient();

export const userRegisterCtrl = async (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { firstname, lastname, email, phoneNumber, password } = req.body;

  try {
    const emailFound = await prisma.user.findUnique({ where: { email: email } });
    if (emailFound) {
      const error = new Error('L\'email existe dÃ©jÃ ') as ErrorWithStatus;
      error.status = 400;
      throw error;
    }

    const phoneNumberFound = await prisma.user.findUnique({ where: { phoneNumber: phoneNumber } });
    if (phoneNumberFound) {
      const error = new Error('Le numÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ ') as ErrorWithStatus;
      error.status = 400;
      throw error;
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const newUser = await prisma.user.create({
      data: { firstname, lastname, email, phoneNumber, password: hashedPassword }
    });

    const accessToken = generateAccessToken(newUser);
    const refreshToken = generateRefreshToken(newUser);

    await prisma.refreshTokens.create({
      data: { hashedToken: refreshToken, userId: newUser.id }
    });

    res.json({
      status: 'success',
      data: { user: newUser, accessToken, refreshToken }
    });
  } catch (err) {
    next(err);
  }
};

export const userLoginCtrl = async (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, password } = req.body;

  try {
    const user = await prisma.user.findUnique({ where: { email: email } });
    if (!user) {
      const error = new Error('Email incorrect') as ErrorWithStatus;
      error.status = 400;
      throw error;
    }

    const validatePassword = await bcrypt.compare(password, user.password);
    if (!validatePassword) {
      const error = new Error('Mot de passe incorrect') as ErrorWithStatus;
      error.status = 400;
      throw error;
    }

    const accessToken = generateAccessToken(user);
    const refreshToken = generateRefreshToken(user);

    await prisma.refreshTokens.create({
      data: { hashedToken: refreshToken, userId: user.id }
    });

    res.json({
      status: 'success',
      data: {
        firstname: user.firstname,
        lastname: user.lastname,
        email: user.email,
        role: user.role,
        accessToken,
        refreshToken
      }
    });
  } catch (err) {
    next(err);
  }
};
```

### Conclusion

En suivant ces Ã©tapes, vous avez :

1. CrÃ©Ã© un middleware global de gestion des erreurs.
2. AjoutÃ© ce middleware Ã  votre application Express.
3. Mis Ã  jour vos contrÃ´leurs pour utiliser `next()` afin de transmettre les erreurs au middleware de gestion des erreurs.

Cela garantit que toutes les erreurs sont gÃ©rÃ©es de maniÃ¨re cohÃ©rente et renvoyÃ©es avec un format standardisÃ©, ce qui facilite le dÃ©bogage et amÃ©liore l'expÃ©rience des utilisateurs.
```javascript
```





```javascript
export const userRegisterCtrl = async( req: Request, res: Response) => {

    // 1. Validation des entrer pour s'assurer que les frmat sont bon
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    // 2. Recuperation des donnes du cors de la requete
    const {
        firstname,
        lastname,
        email,
        phoneNumber,
        password
    } = req.body

    try {
        // 3. validation ou verification de l'existance de l'email
        const emailFound = await prisma.user.findUnique({
            where: {
                email: email
            }
        });
        if (emailFound) {
            return res.status(400).json({
                message: 'Ce email est deja dans la base. Merci d\'en prendre un autre'
            });
        }

        // 4. pareil pour le numero de telephone
        const researchPhoneNumber = await prisma.user.findUnique({
            where: {
                phoneNumber: phoneNumber
            }
        });
        if (researchPhoneNumber) {
            return res.status(400).json({
                message: 'Ce numero de telephon est dÃ©jÃ  utilisÃ©, Merci d\'en choisir un autre'
            });
        }

        // 5.cryptage du mot de passe
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        // 6. Creation d'un nouvelle user dans la base
        const newUser = await prisma.user.create({
            data: {
                firstname,
                lastname,
                email,
                phoneNumber,
                password: hashedPassword
            }
        })

    } catch (err) {
        // 7. Gestion des erreurs
        const error = err as Error;
        res.status(500).json({
            status: 'fail',
            message: error.message
        })
    }
}
```

nouveau

```javascript
```






# PAGINATION



Pour ajouter la pagination lors de l'affichage de tous les utilisateurs, nous pouvons utiliser les paramÃ¨tres de requÃªte (`query parameters`) pour dÃ©finir la page et la limite. Voici comment vous pouvez le faire :

### 1. Ajouter une route pour obtenir tous les utilisateurs avec pagination

CrÃ©ez une nouvelle route dans `src/routes/userRoutes.ts` :

```typescript
import { Router } from 'express';
import { getUserProfile, getAllUsers } from '../controllers/userController';
import { authenticateToken } from '../middleware/authMiddleware';

const router = Router();

router.get('/profile', authenticateToken, getUserProfile);

// Route pour obtenir tous les utilisateurs avec pagination
router.get('/all', authenticateToken, getAllUsers);

export default router;
```

### 2. CrÃ©er le contrÃ´leur pour obtenir tous les utilisateurs avec pagination

Ajoutez une nouvelle fonction dans `src/controllers/userController.ts` :

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const getUserProfile = async (req: Request, res: Response, next: NextFunction) => {
  const userId = (req as any).userId;

  try {
    const user = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      return res.status(404).json({ status: 'fail', message: 'Utilisateur non trouvÃ©' });
    }

    res.json({
      status: 'success',
      data: {
        firstname: user.firstname,
        lastname: user.lastname,
        email: user.email,
        phoneNumber: user.phoneNumber,
        role: user.role
      }
    });
  } catch (err) {
    next(err);
  }
};

export const getAllUsers = async (req: Request, res: Response, next: NextFunction) => {
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 10;
  const skip = (page - 1) * limit;

  try {
    const users = await prisma.user.findMany({
      skip: skip,
      take: limit,
    });

    const totalUsers = await prisma.user.count();

    res.json({
      status: 'success',
      data: {
        users: users,
        totalUsers: totalUsers,
        page: page,
        totalPages: Math.ceil(totalUsers / limit)
      }
    });
  } catch (err) {
    next(err);
  }
};
```

### 3. Tester la pagination

Pour tester la pagination, lancez votre serveur et utilisez une application de test de l'API comme Postman ou Curl pour faire une requÃªte GET Ã  l'URL :

```
GET http://localhost:3000/user/all?page=1&limit=10
```

Cela devrait renvoyer les utilisateurs paginÃ©s avec les informations suivantes :
- `users`: La liste des utilisateurs pour la page actuelle.
- `totalUsers`: Le nombre total d'utilisateurs dans la base de donnÃ©es.
- `page`: La page actuelle.
- `totalPages`: Le nombre total de pages.

### Exemple de rÃ©ponse JSON pour la pagination

```json
{
  "status": "success",
  "data": {
    "users": [
      {
        "id": "1",
        "firstname": "John",
        "lastname": "Doe",
        "email": "john.doe@example.com",
        "phoneNumber": "123456789",
        "role": "USER"
      },
      {
        "id": "2",
        "firstname": "Jane",
        "lastname": "Doe",
        "email": "jane.doe@example.com",
        "phoneNumber": "987654321",
        "role": "ADMIN"
      }
    ],
    "totalUsers": 50,
    "page": 1,
    "totalPages": 5
  }
}
```

Avec cette configuration, vous pouvez facilement gÃ©rer la pagination pour afficher les utilisateurs par lots, ce qui rend la gestion des utilisateurs plus efficace et conviviale.
```javascript
```








# email verification

Pour valider les adresses email et s'assurer qu'elles sont valides et existent, il existe plusieurs approches. Une mÃ©thode courante consiste Ã  envoyer un email de vÃ©rification contenant un lien que l'utilisateur doit cliquer pour vÃ©rifier son adresse email. Cela ne garantit pas que l'adresse email est de Google, mais cela garantit que l'adresse email existe et que l'utilisateur a accÃ¨s Ã  celle-ci.

Cependant, si vous voulez vous assurer qu'une adresse email appartient Ã  Google (comme une adresse Gmail), vous pouvez vÃ©rifier le domaine de l'email. Ensuite, pour valider l'email, vous devez envoyer un email de vÃ©rification.

### Ã‰tapes pour l'authentification par email

1. **Ajouter un champ `verificationToken` et `emailVerified` au modÃ¨le `User`**
2. **CrÃ©er une fonction pour gÃ©nÃ©rer des tokens de vÃ©rification**
3. **Mettre Ã  jour le contrÃ´leur de registre pour envoyer un email de vÃ©rification**
4. **CrÃ©er une route pour vÃ©rifier le token de l'email**
5. **Configurer un service d'envoi d'emails**

### 1. Ajouter un champ `verificationToken` et `emailVerified` au modÃ¨le `User`

Mettez Ã  jour votre schÃ©ma Prisma pour inclure ces champs :

```prisma
model User {
  id                    String          @id @default(auto()) @map("_id") @db.ObjectId
  firstname             String?
  lastname              String?
  email                 String          @unique
  phoneNumber           String          @unique
  password              String
  role                  Role            @default(USER)
  refreshTokens         RefreshTokens[]
  address               Address?
  profession            String?
  birth                 DateTime?
  profilePhoto          String?
  ipAdress              String[]
  deviceId              String[]
  status                Status          @default(inactive)
  isVerified            Boolean         @default(false)
  isApproved            Boolean         @default(false)
  isBlocked             Boolean         @default(false)
  referrralCode         String?
  emailVerifiedAt       DateTime?
  profileComplete       DateTime?
  isSuperuser           Boolean         @default(false)
  identificationType    String?
  identificationExpiry  DateTime?
  documentIdentityImage String?
  statusKyc             Kyc             @default(none)
  dateOfVerification    DateTime?
  sponsorShipCode       String?
  lastLogin             DateTime?
  twoFactorAuth         Boolean         @default(false)
  failedLoginAttempts   Int             @default(0)
  lastFailedLogin       DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  // Nouveaux champs pour l'authentification par email
  verificationToken     String?
  emailVerified         Boolean         @default(false)
}
```

### 2. CrÃ©er une fonction pour gÃ©nÃ©rer des tokens de vÃ©rification

Ajoutez une fonction dans `src/utils/tokenJwt/jwt.ts` :

```typescript
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret_key';

export const generateEmailVerificationToken = (user: { id: string; email: string }) => {
  return jwt.sign({ userId: user.id, email: user.email }, JWT_SECRET, { expiresIn: '1h' });
};
```

### 3. Mettre Ã  jour le contrÃ´leur de registre pour envoyer un email de vÃ©rification

Mettez Ã  jour `src/controllers/authController.ts` :

```typescript
import nodemailer from 'nodemailer';
import { generateEmailVerificationToken } from '../utils/tokenJwt/jwt';

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.GMAIL_USER,
    pass: process.env.GMAIL_PASS,
  },
});

export const userRegisterCtrl = async (req: Request, res: Response, next: NextFunction) => {
  const { firstname, lastname, email, phoneNumber, password } = req.body;

  try {
    const emailFound = await prisma.user.findUnique({ where: { email: email } });
    if (emailFound) {
      const error = new Error('L\'email existe dÃ©jÃ ') as ErrorWithStatus;
      error.status = 400;
      throw error;
    }

    const phoneNumberFound = await prisma.user.findUnique({ where: { phoneNumber: phoneNumber } });
    if (phoneNumberFound) {
      const error = new Error('Le numÃ©ro de tÃ©lÃ©phone existe dÃ©jÃ ') as ErrorWithStatus;
      error.status = 400;
      throw error;
    }

    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const verificationToken = generateEmailVerificationToken({ id: newUser.id, email: email });

    const newUser = await prisma.user.create({
      data: {
        firstname,
        lastname,
        email,
        phoneNumber,
        password: hashedPassword,
        verificationToken,
      },
    });

    const verificationLink = `${process.env.BASE_URL}/auth/verify-email?token=${verificationToken}`;

    await transporter.sendMail({
      from: process.env.GMAIL_USER,
      to: newUser.email,
      subject: 'Verify your email',
      text: `Please verify your email by clicking the following link: ${verificationLink}`,
    });

    res.json({
      status: 'success',
      data: newUser,
    });
    console.log('Utilisateur crÃ©Ã© avec succÃ¨s');
  } catch (err) {
    next(err);
  }
};
```

### 4. CrÃ©er une route pour vÃ©rifier le token de l'email

Ajoutez une nouvelle route dans `src/routes/authRoutes.ts` :

```typescript
router.get('/verify-email', async (req: Request, res: Response, next: NextFunction) => {
  const token = req.query.token as string;

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as { userId: string; email: string };

    const user = await prisma.user.update({
      where: { id: decoded.userId },
      data: { emailVerified: true, emailVerifiedAt: new Date() },
    });

    res.json({
      status: 'success',
      message: 'Email verified successfully',
    });
  } catch (err) {
    const error = new Error('Invalid or expired token') as ErrorWithStatus;
    error.status = 400;
    next(error);
  }
});
```

### 5. Configurer un service d'envoi d'emails

Assurez-vous d'avoir configurÃ© `nodemailer` et d'avoir les variables d'environnement appropriÃ©es dans votre fichier `.env` :

```
GMAIL_USER=your_gmail_account@gmail.com
GMAIL_PASS=your_gmail_password
BASE_URL=http://localhost:3000
```

### Conclusion

Avec ces Ã©tapes, vous avez mis en place un systÃ¨me pour vÃ©rifier les adresses email des utilisateurs. Cela inclut l'envoi d'un email de vÃ©rification aprÃ¨s l'inscription et la vÃ©rification du token de l'email pour activer l'adresse email. Cela garantit que les adresses email sont valides et que l'utilisateur a accÃ¨s Ã  l'email fourni lors de l'inscription.
```javascript
```






















# reset password
Pour implÃ©menter la fonctionnalitÃ© de rÃ©initialisation de mot de passe (mot de passe oubliÃ©) dans votre application, vous pouvez suivre ces Ã©tapes :

### 1. Demande de rÃ©initialisation de mot de passe

CrÃ©ez une route dans votre application pour que les utilisateurs puissent demander la rÃ©initialisation de leur mot de passe. Cette route peut Ãªtre accessible via un formulaire sur votre frontend.

### 2. GÃ©nÃ©ration d'un jeton de rÃ©initialisation de mot de passe

Lorsqu'un utilisateur demande la rÃ©initialisation de son mot de passe, gÃ©nÃ©rez un jeton de rÃ©initialisation de mot de passe unique associÃ© Ã  cet utilisateur. Ce jeton doit expirer aprÃ¨s une certaine durÃ©e pour des raisons de sÃ©curitÃ©.

### 3. Envoi d'un email de rÃ©initialisation de mot de passe

Envoyez un email Ã  l'utilisateur contenant un lien spÃ©cial qui inclut le jeton de rÃ©initialisation de mot de passe. Ce lien doit pointer vers une page oÃ¹ l'utilisateur pourra saisir un nouveau mot de passe.

### 4. RÃ©ception de la demande de rÃ©initialisation de mot de passe

CrÃ©ez une route dans votre application pour gÃ©rer la rÃ©ception du jeton de rÃ©initialisation de mot de passe et permettre Ã  l'utilisateur de saisir un nouveau mot de passe.

### 5. Validation du jeton de rÃ©initialisation de mot de passe

VÃ©rifiez si le jeton de rÃ©initialisation de mot de passe est valide et n'a pas expirÃ©. Si le jeton est valide, permettez Ã  l'utilisateur de saisir un nouveau mot de passe.

### 6. RÃ©initialisation du mot de passe

Une fois que l'utilisateur a saisi un nouveau mot de passe, mettez Ã  jour le mot de passe de l'utilisateur dans votre base de donnÃ©es.

### Exemple de processus dans le contrÃ´leur :

```typescript
// controllers/authController.ts

import { Request, Response } from 'express';
import { generateResetToken, hashPassword } from '../utils/password';
import { sendPasswordResetEmail } from '../utils/email';

export const requestPasswordReset = async (req: Request, res: Response) => {
  const { email } = req.body;

  // VÃ©rifier si l'utilisateur avec cet email existe
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }

  // GÃ©nÃ©rer un jeton de rÃ©initialisation de mot de passe
  const resetToken = generateResetToken(user.id);

  // Enregistrer le jeton de rÃ©initialisation de mot de passe dans la base de donnÃ©es
  await prisma.passwordReset.create({
    data: {
      userId: user.id,
      token: resetToken,
      expiresAt: new Date(Date.now() + 3600000), // Expiration dans 1 heure
    },
  });

  // Envoyer un email de rÃ©initialisation de mot de passe Ã  l'utilisateur
  await sendPasswordResetEmail(email, resetToken);

  res.json({ message: 'Password reset email sent' });
};

export const resetPassword = async (req: Request, res: Response) => {
  const { token, newPassword } = req.body;

  // Trouver le jeton de rÃ©initialisation de mot de passe dans la base de donnÃ©es
  const resetToken = await prisma.passwordReset.findUnique({ where: { token } });
  if (!resetToken || resetToken.expiresAt < new Date()) {
    return res.status(400).json({ message: 'Invalid or expired token' });
  }

  // Mettre Ã  jour le mot de passe de l'utilisateur dans la base de donnÃ©es
  const hashedPassword = await hashPassword(newPassword);
  await prisma.user.update({
    where: { id: resetToken.userId },
    data: { password: hashedPassword },
  });

  // Supprimer le jeton de rÃ©initialisation de mot de passe de la base de donnÃ©es
  await prisma.passwordReset.delete({ where: { token } });

  res.json({ message: 'Password reset successfully' });
};
```

Assurez-vous d'ajouter la gestion des erreurs et les fonctionnalitÃ©s supplÃ©mentaires nÃ©cessaires, telles que la validation des entrÃ©es utilisateur et la protection contre les attaques par force brute, dans votre implÃ©mentation rÃ©elle.
```javascript
```
```javascript
```






# connexion soit email soit password

Pour permettre aux utilisateurs de se connecter Ã  la plateforme en utilisant soit leur adresse e-mail soit leur numÃ©ro de tÃ©lÃ©phone, vous pouvez suivre ces Ã©tapes :

### 1. Modification du modÃ¨le User

Modifiez votre modÃ¨le `User` pour inclure le numÃ©ro de tÃ©lÃ©phone en tant que champ unique, en plus de l'adresse e-mail.

```typescript
// Prisma schema
model User {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  firstname    String?
  lastname     String?
  email        String   @unique
  phoneNumber  String?  @unique // Ajout du champ numÃ©ro de tÃ©lÃ©phone
  password     String
  role         String
}
```

### 2. CrÃ©ation d'une route de connexion

CrÃ©ez une route dans votre application qui accepte l'adresse e-mail ou le numÃ©ro de tÃ©lÃ©phone, ainsi que le mot de passe de l'utilisateur pour l'authentification.

### 3. ContrÃ´leur de connexion

ImplÃ©mentez un contrÃ´leur qui vÃ©rifie si l'utilisateur existe dans la base de donnÃ©es en utilisant soit son adresse e-mail soit son numÃ©ro de tÃ©lÃ©phone, puis vÃ©rifie si le mot de passe fourni correspond au mot de passe enregistrÃ©.

```typescript
// controllers/authController.ts

export const loginUser = async (req: Request, res: Response) => {
  const { identifier, password } = req.body;

  // VÃ©rifier si l'identifiant est un email ou un numÃ©ro de tÃ©lÃ©phone
  const user = await prisma.user.findFirst({
    where: {
      OR: [
        { email: identifier },
        { phoneNumber: identifier }
      ]
    }
  });
  if (!user) {
    return res.status(404).json({ message: 'User not found' });
  }

  // VÃ©rifier si le mot de passe est correct
  const validPassword = await bcrypt.compare(password, user.password);
  if (!validPassword) {
    return res.status(401).json({ message: 'Incorrect password' });
  }

  // Authentification rÃ©ussie, gÃ©nÃ©rer un token JWT
  const token = generateAccessToken(user.id);

  res.json({ token });
};
```

### Exemple de donnÃ©es JSON pour la connexion

Voici un exemple de donnÃ©es JSON que vous pouvez utiliser pour tester la fonctionnalitÃ© de connexion dans Insomnia :

```json
{
  "identifier": "john.doe@example.com",
  "password": "password123"
}
```

Vous pouvez modifier la valeur de `identifier` pour tester la connexion Ã  l'aide de l'adresse e-mail ou du numÃ©ro de tÃ©lÃ©phone de l'utilisateur. Assurez-vous que le mot de passe correspond Ã  celui enregistrÃ© dans votre base de donnÃ©es.
```javascript
```
```javascript
```



D'accord, je comprends mieux maintenant. Voici comment vous pouvez implÃ©menter le processus de vÃ©rification du numÃ©ro de tÃ©lÃ©phone avec envoi d'un code OTP et validation lors de l'inscription :

### 1. Route pour la demande de code OTP

CrÃ©ez une route dans votre application pour que l'utilisateur puisse demander l'envoi du code OTP aprÃ¨s avoir saisi son numÃ©ro de tÃ©lÃ©phone lors de l'inscription.

```typescript
// routes/authRoutes.ts

import { Router } from 'express';
import { requestOTP } from '../controllers/authController';

const router = Router();

router.post('/request-otp', requestOTP);

export default router;
```

### 2. ContrÃ´leur pour la demande de code OTP

ImplÃ©mentez un contrÃ´leur qui gÃ©nÃ¨re et envoie le code OTP Ã  l'utilisateur via SMS, puis stocke ce code dans la base de donnÃ©es associÃ© Ã  l'utilisateur.

```typescript
// controllers/authController.ts

export const requestOTP = async (req: Request, res: Response) => {
  const { phoneNumber } = req.body;

  // GÃ©nÃ©rer un code OTP
  const otp = generateOTP(); // Ã€ implÃ©menter selon votre mÃ©thode de gÃ©nÃ©ration

  // Envoyer le code OTP Ã  l'utilisateur via SMS (utilisez un service comme Twilio)

  // Stocker le code OTP dans la base de donnÃ©es associÃ© Ã  l'utilisateur
  await prisma.user.update({
    where: { phoneNumber },
    data: { otp }
  });

  res.json({ message: 'Code OTP envoyÃ© avec succÃ¨s.' });
};
```

### 3. Route pour la validation du code OTP

CrÃ©ez une autre route pour que l'utilisateur puisse soumettre le code OTP qu'il a reÃ§u afin de valider son numÃ©ro de tÃ©lÃ©phone.

```typescript
// routes/authRoutes.ts

import { Router } from 'express';
import { verifyOTP } from '../controllers/authController';

const router = Router();

router.post('/verify-otp', verifyOTP);

export default router;
```

### 4. ContrÃ´leur pour la validation du code OTP

ImplÃ©mentez un contrÃ´leur qui vÃ©rifie si le code OTP soumis par l'utilisateur correspond Ã  celui stockÃ© dans la base de donnÃ©es. Si la correspondance est rÃ©ussie, marquez le numÃ©ro de tÃ©lÃ©phone comme vÃ©rifiÃ©.

```typescript
// controllers/authController.ts

export const verifyOTP = async (req: Request, res: Response) => {
  const { phoneNumber, otp } = req.body;

  // VÃ©rifier le code OTP dans la base de donnÃ©es
  const user = await prisma.user.findFirst({
    where: { phoneNumber, otp }
  });

  if (!user) {
    return res.status(401).json({ message: 'Code OTP invalide.' });
  }

  // Marquer le numÃ©ro de tÃ©lÃ©phone comme vÃ©rifiÃ©
  await prisma.user.update({
    where: { phoneNumber },
    data: { phoneNumberVerified: true, otp: null } // RÃ©initialiser le code OTP aprÃ¨s vÃ©rification
  });

  res.json({ message: 'NumÃ©ro de tÃ©lÃ©phone vÃ©rifiÃ© avec succÃ¨s.' });
};
```

### Exemple de donnÃ©es JSON pour la demande de code OTP

Voici un exemple de donnÃ©es JSON que vous pouvez utiliser pour tester la demande de code OTP dans Insomnia :

```json
{
  "phoneNumber": "+1234567890"
}
```

Vous pouvez ajuster la valeur de `"phoneNumber"` en fonction du numÃ©ro de tÃ©lÃ©phone pour lequel vous souhaitez demander l'envoi du code OTP. Assurez-vous que votre contrÃ´leur envoie rÃ©ellement le code OTP via SMS.
```javascript
```
```javascript
```
```javascript
```



Bien sÃ»r, je vais dÃ©velopper cette fonction `requestOTP` pour vous :

```typescript
// controllers/authController.ts

import { Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';
import { generateOTP } from '../utils/otp'; // Importez la fonction de gÃ©nÃ©ration de code OTP

const prisma = new PrismaClient();

export const requestOTP = async (req: Request, res: Response) => {
  const { phoneNumber } = req.body;

  try {
    // GÃ©nÃ©ration d'un code OTP
    const otp = generateOTP(); // Ã€ implÃ©menter selon votre mÃ©thode de gÃ©nÃ©ration

    // Envoyer le code OTP Ã  l'utilisateur via SMS (utilisez un service comme Twilio)
    // Ici, vous devez appeler un service externe comme Twilio pour envoyer le code OTP

    // Stocker le code OTP dans la base de donnÃ©es associÃ© Ã  l'utilisateur
    await prisma.user.update({
      where: { phoneNumber },
      data: { otp }
    });

    res.json({ message: 'Code OTP envoyÃ© avec succÃ¨s.' });
  } catch (error) {
    console.error('Erreur lors de la demande de code OTP :', error);
    res.status(500).json({ message: 'Une erreur est survenue lors de l\'envoi du code OTP.' });
  }
};
```

Dans cette fonction `requestOTP`, nous gÃ©nÃ©rons un code OTP, puis nous devons envoyer ce code Ã  l'utilisateur via SMS. Cette partie dÃ©pend d'un service externe comme Twilio pour l'envoi de SMS. Une fois que le code OTP est envoyÃ© avec succÃ¨s, nous le stockons dans la base de donnÃ©es associÃ© Ã  l'utilisateur.

Assurez-vous d'adapter cette fonction en fonction de votre mÃ©thode de gÃ©nÃ©ration de code OTP et de votre service d'envoi de SMS. Et n'oubliez pas de gÃ©rer les erreurs de maniÃ¨re appropriÃ©e pour fournir des rÃ©ponses claires Ã  l'utilisateur en cas de problÃ¨me lors de l'envoi du code OTP.
```javascript
```
```javascript
```

# migration sql vs mongo

Pour migrer une base de donnÃ©es SQL vers MongoDB avec Prisma et prendre en compte les cas oÃ¹ les anciens utilisateurs n'ont pas d'adresse e-mail et peuvent continuer Ã  utiliser leur mÃ©thode de connexion actuelle, vous devrez suivre plusieurs Ã©tapes :

### 1. Mettre Ã  jour le schÃ©ma Prisma :

Ajoutez le champ `email` dans votre modÃ¨le `User` et assurez-vous qu'il n'est pas dÃ©fini comme `@unique` si vous souhaitez permettre aux anciens utilisateurs de ne pas avoir d'adresse e-mail.

```prisma
model User {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  firstname    String?
  lastname     String?
  email        String?
  phoneNumber  String  @unique
  password     String
  role         String
}
```

### 2. Migration des donnÃ©es :

Migrez vos donnÃ©es de la base de donnÃ©es SQL vers MongoDB en prenant soin de conserver les donnÃ©es des anciens utilisateurs. Si un utilisateur n'a pas d'adresse e-mail, vous pouvez laisser ce champ vide ou le remplir avec une valeur par dÃ©faut, selon vos besoins.

### 3. Mettre Ã  jour la logique de connexion :

Dans votre logique de connexion, vÃ©rifiez si l'utilisateur a un e-mail. Si c'est le cas, autorisez la connexion par e-mail. Sinon, autorisez la connexion par numÃ©ro de tÃ©lÃ©phone.

### 4. Mettre Ã  jour le processus d'inscription :

Pour les nouveaux utilisateurs, demandez obligatoirement une adresse e-mail lors de l'inscription. Si vous utilisez un formulaire d'inscription, ajoutez un champ pour l'e-mail et assurez-vous que ce champ est valide avant de crÃ©er le nouvel utilisateur.

### 5. Autoriser les anciens utilisateurs Ã  renseigner leur e-mail :

CrÃ©ez une fonctionnalitÃ© dans votre application qui permet aux anciens utilisateurs de renseigner leur adresse e-mail ultÃ©rieurement. Cette fonctionnalitÃ© peut Ãªtre une page de profil oÃ¹ les utilisateurs peuvent mettre Ã  jour leurs informations personnelles.

En suivant ces Ã©tapes, vous pourrez migrer votre base de donnÃ©es SQL vers MongoDB avec Prisma tout en tenant compte des diffÃ©rences dans les mÃ©thodes de connexion entre les anciens et les nouveaux utilisateurs. Assurez-vous de tester soigneusement la migration pour Ã©viter toute perte de donnÃ©es ou tout dysfonctionnement dans votre application.
```javascript
```
```javascript
```
Pour migrer les donnÃ©es d'une base de donnÃ©es SQL vers MongoDB avec Prisma, vous pouvez suivre ces Ã©tapes gÃ©nÃ©rales :

### 1. Exporter les donnÃ©es de la base de donnÃ©es SQL :

Utilisez des outils de migration de donnÃ©es ou des scripts SQL pour extraire les donnÃ©es de votre base de donnÃ©es SQL dans un format adaptÃ© Ã  l'importation dans MongoDB. Vous pouvez exporter les donnÃ©es sous forme de fichiers CSV, JSON ou tout autre format pris en charge par MongoDB.

### 2. Transformer les donnÃ©es si nÃ©cessaire :

Si les donnÃ©es exportÃ©es ne sont pas directement compatibles avec le schÃ©ma MongoDB, vous devrez peut-Ãªtre les transformer pour les adapter. Par exemple, vous pourriez avoir besoin de reformater les dates ou de normaliser les valeurs pour correspondre au schÃ©ma MongoDB.

### 3. Importer les donnÃ©es dans MongoDB :

Utilisez les outils de gestion de base de donnÃ©es ou les API fournis par MongoDB pour importer les donnÃ©es exportÃ©es dans votre base de donnÃ©es MongoDB. Assurez-vous de suivre les instructions spÃ©cifiques Ã  votre environnement et de vÃ©rifier que les donnÃ©es sont importÃ©es correctement.

### 4. Mettre Ã  jour le schÃ©ma Prisma :

Une fois les donnÃ©es importÃ©es dans MongoDB, assurez-vous que votre schÃ©ma Prisma est mis Ã  jour pour reflÃ©ter les changements. Cela peut inclure l'ajout de nouveaux modÃ¨les, de nouveaux champs ou la modification des contraintes existantes pour correspondre Ã  la structure de donnÃ©es dans MongoDB.

### 5. Tester la migration :

Effectuez des tests exhaustifs pour vous assurer que les donnÃ©es ont Ã©tÃ© migrÃ©es avec succÃ¨s et que votre application fonctionne correctement avec la nouvelle base de donnÃ©es MongoDB. VÃ©rifiez que toutes les fonctionnalitÃ©s sont opÃ©rationnelles et que les donnÃ©es sont accessibles comme prÃ©vu.

### 6. GÃ©rer les erreurs et les incohÃ©rences :

Pendant le processus de migration et de test, il est probable que vous rencontriez des erreurs ou des incohÃ©rences dans les donnÃ©es. Assurez-vous d'avoir des mÃ©canismes en place pour gÃ©rer ces problÃ¨mes, que ce soit en corrigeant manuellement les donnÃ©es, en mettant Ã  jour les scripts de migration ou en apportant des modifications au schÃ©ma Prisma.

En suivant ces Ã©tapes, vous devriez Ãªtre en mesure de migrer les donnÃ©es de votre base de donnÃ©es SQL vers MongoDB avec Prisma de maniÃ¨re efficace et sans perte de donnÃ©es importantes. Assurez-vous de sauvegarder vos donnÃ©es et de planifier la migration pendant une pÃ©riode de faible trafic pour minimiser les perturbations potentielles pour vos utilisateurs.
```javascript
```
```javascript
```

















# Verifier que l'otp du user a ete verifier


Pour vÃ©rifier que l'OTP a bien Ã©tÃ© vÃ©rifiÃ©, vous pouvez ajouter un champ `isVerified` par dÃ©faut Ã  `false` dans le modÃ¨le `User`. Ce champ sera mis Ã  jour Ã  `true` lorsque l'utilisateur vÃ©rifiera son OTP. Voici comment vous pouvez le faire :

### Mise Ã  Jour du ModÃ¨le `User`

Ajoutez le champ `isVerified` dans votre modÃ¨le `User` :

```prisma
model User {
  id                    String                @id @default(auto()) @map("_id") @db.ObjectId
  firstname             String?
  lastname              String?
  email                 String                @unique
  phoneNumber           String                @unique
  password              String
  role                  Role                  @default(USER)
  refreshTokens         RefreshTokens[]
  address               Address?
  profession            String?
  birth                 DateTime?
  profilePhoto          String?
  ipAdress              String[]
  deviceId              String[]
  status                Status                @default(inactive)
  isApproved            Boolean               @default(false)
  isBlocked             Boolean               @default(false)
  referrralCode         String?
  otpVerifications      UserOtpVerification[]
  profileComplete       DateTime?
  isSuperuser           Boolean               @default(false)
  identificationType    String?
  identificationExpiry  DateTime?
  documentIdentityImage String?
  statusKyc             Kyc                   @default(none)
  dateOfVerification    DateTime?
  sponsorShipCode       String?
  lastLogin             DateTime?
  twoFactorAuth         Boolean               @default(false)
  failedLoginAttempts   Int                   @default(0)
  lastFailedLogin       DateTime?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  isVerified            Boolean               @default(false) // Ajout du champ isVerified
}
```

### Mise Ã  Jour du ContrÃ´leur de VÃ©rification de l'OTP

Modifiez le contrÃ´leur de vÃ©rification de l'OTP pour mettre Ã  jour le champ `isVerified` :

```typescript
import { Request, Response, NextFunction } from 'express';
import prisma from '../prisma'; // Assurez-vous que le chemin est correct

export const verifyOtpCtrl = async (req: Request, res: Response, next: NextFunction) => {
    const { email, otp } = req.body;

    try {
        // Rechercher l'utilisateur par email
        const user = await prisma.user.findUnique({
            where: { email },
            include: {
                otpVerifications: true,
            }
        });

        if (!user) {
            return res.status(400).json({ error: 'User not found' });
        }

        // VÃ©rifier que l'OTP existe et n'est pas expirÃ©
        const validOtp = user.otpVerifications.find((verification) => 
            verification.otp === otp && verification.otpExpires > new Date()
        );

        if (!validOtp) {
            return res.status(400).json({ error: 'Invalid or expired OTP' });
        }

        // Mettre Ã  jour le statut de l'utilisateur
        await prisma.user.update({
            where: { email },
            data: {
                status: 'active',
                isVerified: true, // Met Ã  jour isVerified Ã  true
                otpVerifications: {
                    delete: { id: validOtp.id } // Supprime l'OTP aprÃ¨s vÃ©rification
                }
            }
        });

        res.status(200).json({
            status: 'success',
            message: 'OTP verified successfully. User is now active and verified.'
        });

    } catch (err) {
        next(err);
    }
}
```

### Mise Ã  Jour du ContrÃ´leur de Connexion

Modifiez le contrÃ´leur de connexion pour vÃ©rifier que `isVerified` est `true` avant de permettre la connexion :

```typescript
import { Request, Response, NextFunction } from 'express';
import prisma from '../prisma'; // Assurez-vous que le chemin est correct
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken'; // Si vous utilisez JWT pour l'authentification

export const userLoginCtrl = async (req: Request, res: Response, next: NextFunction) => {
    const { email, password } = req.body;

    try {
        // Rechercher l'utilisateur par email
        const user = await prisma.user.findUnique({
            where: { email }
        });

        if (!user) {
            return res.status(400).json({ error: 'Invalid email or password' });
        }

        // VÃ©rifier que l'utilisateur a vÃ©rifiÃ© son OTP
        if (!user.isVerified) {
            return res.status(403).json({ error: 'Account not verified. Please check your email for the OTP.' });
        }

        // VÃ©rifier le mot de passe
        const isPasswordValid = await bcrypt.compare(password, user.password);
        if (!isPasswordValid) {
            return res.status(400).json({ error: 'Invalid email or password' });
        }

        // GÃ©nÃ©rer un token JWT (ou utiliser une autre mÃ©thode d'authentification)
        const token = jwt.sign({ userId: user.id }, 'your-secret-key', { expiresIn: '1h' });

        // RÃ©pondre avec le token
        res.status(200).json({
            status: 'success',
            message: 'Login successful',
            token
        });

    } catch (err) {
        next(err);
    }
};
```

### Exemple de RequÃªte HTTP pour VÃ©rifier l'OTP

Pour vÃ©rifier l'OTP, vous pouvez envoyer une requÃªte POST avec le payload JSON :

```bash
curl -X POST http://localhost:3000/verify-otp -H "Content-Type: application/json" -d '{"email":"user@gmail.com", "otp":"ABC123"}'
```

### Exemple de RequÃªte HTTP pour se Connecter

Pour se connecter, vous pouvez envoyer une requÃªte POST avec le payload JSON :

```bash
curl -X POST http://localhost:3000/login -H "Content-Type: application/json" -d '{"email":"user@gmail.com", "password":"yourpassword"}'
```

En suivant ces Ã©tapes, vous vous assurez que seuls les utilisateurs qui ont vÃ©rifiÃ© leur adresse email via OTP peuvent se connecter. Le champ `isVerified` dans le modÃ¨le `User` permet de suivre l'Ã©tat de vÃ©rification de chaque utilisateur.


















































OTP EMAIL

Pour configurer l'envoi d'e-mails Ã  l'aide de Nodemailer avec les informations stockÃ©es dans un fichier `.env`, vous devez suivre ces Ã©tapes :

1. **Installer les dÃ©pendances nÃ©cessaires :**

   Assurez-vous d'avoir les bibliothÃ¨ques `dotenv` et `nodemailer` installÃ©es :

   ```bash
   npm install dotenv nodemailer
   ```

2. **Configurer le fichier `.env` :**

   CrÃ©ez un fichier `.env` Ã  la racine de votre projet si ce n'est pas dÃ©jÃ  fait. Ajoutez-y les variables d'environnement nÃ©cessaires pour la configuration de Nodemailer. Par exemple, pour une configuration avec Gmail :

   ```env
   EMAIL_HOST=smtp.gmail.com
   EMAIL_PORT=587
   EMAIL_USER=your-email@gmail.com
   EMAIL_PASS=your-email-password
   ```

   Remplacez `your-email@gmail.com` et `your-email-password` par vos informations de compte Gmail. Notez que pour utiliser Gmail, vous devrez peut-Ãªtre configurer des mots de passe d'application ou autoriser l'accÃ¨s Ã  des applications moins sÃ©curisÃ©es.

3. **Charger les variables d'environnement dans votre application :**

   Utilisez la bibliothÃ¨que `dotenv` pour charger les variables d'environnement au dÃ©marrage de votre application.

   ```typescript
   // server.ts or app.ts (your main entry point)

   import dotenv from 'dotenv';

   dotenv.config();
   ```

4. **Configurer Nodemailer avec les variables d'environnement :**

   CrÃ©ez un fichier de service pour configurer et envoyer des e-mails en utilisant Nodemailer avec les variables d'environnement.

   ```typescript
   // email.service.ts

   import nodemailer from 'nodemailer';

   // Configurer le transporteur d'e-mails
   const transporter = nodemailer.createTransport({
       host: process.env.EMAIL_HOST,
       port: Number(process.env.EMAIL_PORT),
       secure: false, // true pour 465, false pour d'autres ports
       auth: {
           user: process.env.EMAIL_USER,
           pass: process.env.EMAIL_PASS,
       },
   });

   // Fonction pour envoyer un e-mail
   export const sendEmail = async (to: string, subject: string, text: string, html?: string) => {
       const mailOptions = {
           from: process.env.EMAIL_USER, // adresse e-mail de l'expÃ©diteur
           to: to,
           subject: subject,
           text: text,
           html: html, // Si le contenu HTML est fourni
       };

       try {
           const info = await transporter.sendMail(mailOptions);
           console.log('Email sent: ' + info.response);
       } catch (error) {
           console.error('Error sending email: ', error);
       }
   };
   ```

5. **Utilisation du service d'e-mail :**

   Vous pouvez maintenant utiliser la fonction `sendEmail` dans votre application pour envoyer des e-mails. Par exemple, pour envoyer un e-mail de vÃ©rification OTP :

   ```typescript
   import { sendEmail } from './email.service';

   const sendOtpEmail = async (email: string, otp: string) => {
       const subject = 'Votre code OTP de vÃ©rification';
       const text = `Votre code OTP est : ${otp}`;
       const html = `<p>Votre code OTP est : <strong>${otp}</strong></p>`;

       await sendEmail(email, subject, text, html);
   };

   // Exemple d'appel
   sendOtpEmail('user@example.com', '123456');
   ```

### RÃ©sumÃ©

1. Installez `dotenv` et `nodemailer`.
2. Configurez le fichier `.env` avec les informations d'email.
3. Chargez les variables d'environnement dans votre application.
4. Configurez Nodemailer en utilisant ces variables.
5. Utilisez le service d'email pour envoyer des e-mails.

Cette mÃ©thode vous permet de sÃ©curiser les informations sensibles (comme les identifiants d'email) dans le fichier `.env` et de les utiliser de maniÃ¨re sÃ©curisÃ©e dans votre application.












# format gmail

Pour vÃ©rifier que l'email saisi par l'utilisateur est bien du format `@gmail.com`, vous pouvez utiliser une expression rÃ©guliÃ¨re (regex) pour valider le format de l'email. Voici comment vous pouvez le faire en Node.js :

### Utilisation d'une Regex pour Valider le Format de l'Email

1. **CrÃ©er une Regex pour le format `@gmail.com`** :
   ```javascript
   const gmailRegex = /^[a-zA-Z0-9._%+-]+@gmail\.com$/;
   ```

   Cette regex vÃ©rifie que l'email commence par des caractÃ¨res alphanumÃ©riques ou des caractÃ¨res spÃ©ciaux autorisÃ©s, suivi de `@gmail.com`.

2. **Valider l'Email Saisi** :
   ```javascript
   const validateGmail = (email) => {
       return gmailRegex.test(email);
   };
   ```

3. **IntÃ©grer cette Validation dans votre Code** :
   ```javascript
   const email = 'user@gmail.com'; // Exemple d'email saisi par l'utilisateur

   if (validateGmail(email)) {
       console.log('Email is valid and from gmail.com');
       // Continuez avec le reste de votre logique, comme l'envoi d'un email
   } else {
       console.log('Invalid email format or not a gmail.com address');
       // GÃ©rez l'erreur, par exemple en demandant Ã  l'utilisateur de ressaisir l'email
   }
   ```

### Exemple Complet avec Node.js

Voici un exemple complet d'un simple serveur Express qui vÃ©rifie que l'email saisi est bien un `@gmail.com` :

1. **Installer Express** :
   ```bash
   npm install express
   ```

2. **CrÃ©er le Serveur Express** :
   ```javascript
   const express = require('express');
   const bodyParser = require('body-parser');
   const app = express();
   const port = 3000;

   app.use(bodyParser.json());

   const gmailRegex = /^[a-zA-Z0-9._%+-]+@gmail\.com$/;

   const validateGmail = (email) => {
       return gmailRegex.test(email);
   };

   app.post('/validate-email', (req, res) => {
       const { email } = req.body;

       if (validateGmail(email)) {
           res.send('Email is valid and from gmail.com');
       } else {
           res.status(400).send('Invalid email format or not a gmail.com address');
       }
   });

   app.listen(port, () => {
       console.log(`Server running on http://localhost:${port}`);
   });
   ```

3. **Tester l'Application** :
   Vous pouvez tester cette application en envoyant une requÃªte POST avec un email au format JSON Ã  l'endpoint `/validate-email`.

   Exemple avec `curl` :
   ```bash
   curl -X POST http://localhost:3000/validate-email -H "Content-Type: application/json" -d '{"email":"user@gmail.com"}'
   ```

   Cela devrait renvoyer `Email is valid and from gmail.com` si l'email est valide, ou une erreur `Invalid email format or not a gmail.com address` si ce n'est pas le cas.

En utilisant cette mÃ©thode, vous pouvez facilement valider que les emails saisis par les utilisateurs sont bien au format `@gmail.com` avant de procÃ©der Ã  toute autre opÃ©ration, comme l'envoi d'emails.














Pour ajouter la validation du format de l'email `@gmail.com` dans votre contrÃ´leur `userRegisterCtrl`, vous pouvez intÃ©grer une fonction de validation juste aprÃ¨s avoir rÃ©cupÃ©rÃ© les donnÃ©es du corps de la requÃªte. Voici comment faire cela :

### Code ModifiÃ©

```typescript
import { Request, Response, NextFunction } from 'express';
import { validationResult } from 'express-validator';
import prisma from '../prisma'; // Assurez-vous que le chemin est correct
import bcrypt from 'bcrypt';
import crypto from 'crypto';
import sendOTPEmail from '../utils/sendOTPEmail'; // Assurez-vous que le chemin est correct
import { BadRequestException, ErrorCodes } from '../exceptions'; // Assurez-vous que le chemin est correct

export const userRegisterCtrl = async (req: Request, res: Response, next: NextFunction) => {

    // 1. Validation des entrÃ©es pour s'assurer que les formats sont bons
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    // 2. RÃ©cupÃ©ration des donnÃ©es du corps de la requÃªte
    const { firstname, lastname, email, phoneNumber, password } = req.body;

    // VÃ©rification du format de l'email
    const gmailRegex = /^[a-zA-Z0-9._%+-]+@gmail\.com$/;
    if (!gmailRegex.test(email)) {
        return res.status(400).json({ error: 'Invalid email format or not a gmail.com address' });
    }

    try {
        // 3. Validation ou vÃ©rification de l'existence de l'email
        const emailFound = await prisma.user.findUnique({
            where: { email }
        });
        if (emailFound) {
            // CrÃ©er une nouvelle erreur avec un statut personnalisÃ©
            return next(new BadRequestException('Utilisateur existe dÃ©jÃ !', ErrorCodes.USER_ALREADY_EXIST));
        }

        // 4. Pareil pour le numÃ©ro de tÃ©lÃ©phone
        const researchPhoneNumber = await prisma.user.findUnique({
            where: { phoneNumber }
        });
        if (researchPhoneNumber) {
            return next(new BadRequestException('Ce numÃ©ro de tÃ©lÃ©phone est dÃ©jÃ  utilisÃ©, merci d\'en choisir un autre', ErrorCodes.PHONE_NUMBER_ALREADY_EXISTS));
        }

        // 5. Cryptage du mot de passe
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(password, salt);

        // x. GÃ©nÃ©ration d'un code OTP
        const otp = crypto.randomBytes(3).toString('hex').toUpperCase();
        const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10min

        // 6. CrÃ©ation d'un nouvel utilisateur dans la base
        const newUser = await prisma.user.create({
            data: {
                firstname,
                lastname,
                email,
                phoneNumber,
                password: hashedPassword,
                otpVerifications: {
                    create: {
                        otp,
                        otpExpires
                    }
                }
            }
        });

        // Envoi de l'email de vÃ©rification
        await sendOTPEmail(email, otp);

        // RÃ©ponse en cas de succÃ¨s
        res.status(201).json({
            status: 'success',
            message: 'Utilisateur enregistrÃ©. Veuillez vÃ©rifier votre email pour l\'OTP.'
        });

    } catch (err) {
        // 7. Gestion des erreurs
        next(err);
    }
}
```

### Explication des Modifications

1. **Importations** :
   - Assurez-vous que tous les modules nÃ©cessaires sont correctement importÃ©s, notamment `Request`, `Response`, `NextFunction`, `prisma`, `bcrypt`, `crypto`, et votre fonction utilitaire pour envoyer les emails OTP (`sendOTPEmail`).

2. **Validation du Format de l'Email** :
   - J'ai ajoutÃ© une regex pour vÃ©rifier que l'email est bien du format `@gmail.com`. Si l'email ne correspond pas, une rÃ©ponse avec le statut 400 et un message d'erreur est envoyÃ©e.

3. **ContrÃ´le de l'Email** :
   - Avant de vÃ©rifier l'existence de l'email dans la base de donnÃ©es, le format est validÃ©.

4. **Gestion des Erreurs** :
   - Si l'email n'est pas valide, une rÃ©ponse avec une erreur appropriÃ©e est renvoyÃ©e avant toute autre vÃ©rification ou opÃ©ration.

Ces modifications garantissent que seuls les emails de format `@gmail.com` seront acceptÃ©s lors de l'inscription.

















# OTP EMAIL

Pour implÃ©menter l'authentification par OTP (One-Time Password) avec Nodemailer, Node.js, TypeScript, Prisma et MongoDB, suivez ces Ã©tapes :

### 1. Initialiser le Projet

Commencez par initialiser un projet Node.js et installez les dÃ©pendances nÃ©cessaires.

```bash
mkdir otp-authentication
cd otp-authentication
npm init -y
npm install express @prisma/client prisma nodemailer dotenv typescript @types/node @types/express ts-node-dev
npx tsc --init
npx prisma init
```

### 2. Configurer TypeScript

Modifiez le fichier `tsconfig.json` pour adapter la configuration TypeScript Ã  votre projet. Assurez-vous que les options suivantes sont activÃ©es :

```json
{
  "compilerOptions": {
    "target": "ES6",
    "module": "commonjs",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}
```

### 3. Configurer Prisma

Modifiez le fichier `prisma/schema.prisma` pour dÃ©finir le modÃ¨le d'utilisateur en utilisant MongoDB comme source de donnÃ©es.

```prisma
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  email       String   @unique
  otp         String?
  otpExpires  DateTime?
}
```
ou

```javascript
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id       String  @id @default(auto()) @map("_id") @db.ObjectId
  email    String  @unique
  password String
  otpVerifications UserOtpVerification[]
}

model UserOtpVerification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  otp       String
  otpExpires DateTime
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
}

```

ExÃ©cutez les commandes Prisma pour gÃ©nÃ©rer le client.

```bash
npx prisma migrate dev --name init
npx prisma generate
```

### 4. Configurer l'Application Express

CrÃ©ez le fichier `src/app.ts` et configurez Express et Prisma.

```typescript
import express from 'express';
import dotenv from 'dotenv';
import { PrismaClient } from '@prisma/client';

dotenv.config();

const app = express();
const prisma = new PrismaClient();

app.use(express.json());

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
```

### 5. Configurer Nodemailer

CrÃ©ez un fichier `src/config/nodemailer.ts` pour configurer Nodemailer.

```typescript
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';

dotenv.config();

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

export const sendOTPEmail = async (email: string, otp: string) => {
  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: email,
    subject: 'Your OTP Code',
    text: `Your OTP code is ${otp}`,
  };

  await transporter.sendMail(mailOptions);
};
```

### 6. CrÃ©er les ContrÃ´leurs d'Authentification

CrÃ©ez le fichier `src/controllers/authController.ts` pour gÃ©rer l'inscription et l'envoi d'OTP.

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import { sendOTPEmail } from '../config/nodemailer';
import crypto from 'crypto';

const prisma = new PrismaClient();

export const registerUser = async (req: Request, res: Response, next: NextFunction) => {
  const { email } = req.body;

  try {
    const userExists = await prisma.user.findUnique({ where: { email } });

    if (userExists) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const otp = crypto.randomBytes(3).toString('hex');
    const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await prisma.user.create({
      data: {
        email,
        otp,
        otpExpires,
      },
    });

    await sendOTPEmail(email, otp);

    res.status(201).json({ message: 'User registered. Please check your email for the OTP.' });
  } catch (error) {
    next(error);
  }
};

export const verifyOTP = async (req: Request, res: Response, next: NextFunction) => {
  const { email, otp } = req.body;

  try {
    const user = await prisma.user.findUnique({ where: { email } });

    if (!user) {
      return res.status(400).json({ message: 'User not found' });
    }

    if (user.otp !== otp || user.otpExpires < new Date()) {
      return res.status(400).json({ message: 'Invalid or expired OTP' });
    }

    await prisma.user.update({
      where: { email },
      data: {
        otp: null,
        otpExpires: null,
      },
    });

    res.status(200).json({ message: 'OTP verified successfully' });
  } catch (error) {
    next(error);
  }
};
```

### 7. DÃ©finir les Routes

CrÃ©ez le fichier `src/routes/authRoutes.ts` pour dÃ©finir les routes d'authentification.

```typescript
import { Router } from 'express';
import { registerUser, verifyOTP } from '../controllers/authController';

const router = Router();

router.post('/register', registerUser);
router.post('/verify-otp', verifyOTP);

export default router;
```

### 8. Ajouter les Routes Ã  l'Application

Mettez Ã  jour `src/app.ts` pour utiliser les routes d'authentification.

```typescript
import authRoutes from './routes/authRoutes';

app.use('/api/auth', authRoutes);
```

### 9. CrÃ©er un Middleware de Gestion des Erreurs

CrÃ©ez un fichier `src/middleware/errorHandler.ts` pour gÃ©rer les erreurs.

```typescript
import { Request, Response, NextFunction } from 'express';

export const errorHandler = (err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error(err);
  res.status(500).json({ message: err.message });
};
```

Ajoutez ce middleware Ã  votre application dans `src/app.ts`.

```typescript
import { errorHandler } from './middleware/errorHandler';

app.use(errorHandler);
```

### 10. Configurer les Variables d'Environnement

CrÃ©ez un fichier `.env` pour stocker vos variables d'environnement.

```
DATABASE_URL="mongodb+srv://<username>:<password>@cluster0.mongodb.net/mydatabase?retryWrites=true&w=majority"
EMAIL_USER="your-email@gmail.com"
EMAIL_PASS="your-email-password"
PORT=5000
```

### 11. Tester l'Application

Lancez l'application et testez les diffÃ©rentes routes.

```bash
npm run dev
```

Vous devriez maintenant pouvoir vous inscrire avec un email, recevoir un OTP par email, et vÃ©rifier cet OTP pour terminer l'inscription.
```javascript
```
```javascript
```


OPT EMAIL V2

Vous avez deux options pour stocker les informations relatives Ã  l'OTP (One-Time Password) : vous pouvez soit les intÃ©grer directement dans le modÃ¨le `User`, soit crÃ©er un modÃ¨le sÃ©parÃ© pour gÃ©rer les OTP. 

### Option 1: IntÃ©grer les informations OTP dans le modÃ¨le `User`

Cette approche est plus simple et Ã©vite la crÃ©ation d'un modÃ¨le supplÃ©mentaire. Cependant, elle peut rendre le modÃ¨le `User` plus complexe.

```prisma
model User {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  email       String   @unique
  password    String
  otp         String?
  otpExpires  DateTime?
}
```

### Option 2: CrÃ©er un modÃ¨le sÃ©parÃ© pour les OTP

Cette approche est plus modulaire et suit le principe de sÃ©paration des prÃ©occupations, ce qui peut rendre le code plus facile Ã  maintenir Ã  long terme. Dans ce cas, vous aurez un modÃ¨le `User` et un modÃ¨le `UserOtpVerification`.

#### ModÃ¨le `User`

```prisma
model User {
  id       String  @id @default(auto()) @map("_id") @db.ObjectId
  email    String  @unique
  password String
  otpVerifications UserOtpVerification[]
}
```

#### ModÃ¨le `UserOtpVerification`

```prisma
model UserOtpVerification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  otp       String
  otpExpires DateTime
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
}
```

### Choix de l'Approche

#### IntÃ©gration dans le modÃ¨le `User`

**Avantages:**
- SimplicitÃ©.
- Moins de requÃªtes de base de donnÃ©es.

**InconvÃ©nients:**
- Le modÃ¨le `User` peut devenir encombrÃ©.

#### ModÃ¨le sÃ©parÃ© pour les OTP

**Avantages:**
- ModÃ¨le plus propre et modulaire.
- Facilite l'extension des fonctionnalitÃ©s liÃ©es aux OTP.

**InconvÃ©nients:**
- ComplexitÃ© accrue.
- RequÃªtes de base de donnÃ©es supplÃ©mentaires.

### Mise en Place

Pour cet exemple, nous allons utiliser la deuxiÃ¨me option (modÃ¨le sÃ©parÃ© pour les OTP) car elle est plus modulaire et extensible.

### 1. Configurer les ModÃ¨les Prisma

Modifiez votre fichier `schema.prisma` :

```prisma
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id       String  @id @default(auto()) @map("_id") @db.ObjectId
  email    String  @unique
  password String
  otpVerifications UserOtpVerification[]
}

model UserOtpVerification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  otp       String
  otpExpires DateTime
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id])
}
```

### 2. Migrer la Base de DonnÃ©es

GÃ©nÃ©rez le client Prisma et appliquez les migrations :

```bash
npx prisma migrate dev --name add_user_otp_verification
npx prisma generate
```

### 3. CrÃ©er les ContrÃ´leurs d'OTP

#### `registerUser`

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import { sendOTPEmail } from '../config/nodemailer';
import crypto from 'crypto';
import { BadRequestException } from '../exceptions/root';
import { ErrorCodes } from '../exceptions/errorCodes';

const prisma = new PrismaClient();

export const registerUser = async (req: Request, res: Response, next: NextFunction) => {
  const { email, password } = req.body;

  try {
    const userExists = await prisma.user.findUnique({ where: { email } });

    if (userExists) {
      return next(new BadRequestException('Utilisateur exite deja!', ErrorCodes.USER_ALREADY_EXIST));
    }

    const otp = crypto.randomBytes(3).toString('hex');
    const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    const newUser = await prisma.user.create({
      data: {
        email,
        password,
        otpVerifications: {
          create: {
            otp,
            otpExpires,
          },
        },
      },
    });

    await sendOTPEmail(email, otp);

    res.status(201).json({ message: 'Utilisateur enregistrÃ©. Veuillez vÃ©rifier votre email pour l\'OTP.' });
  } catch (error) {
    next(error);
  }
};
```

#### `verifyOTP`

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import { BadRequestException } from '../exceptions/root';
import { ErrorCodes } from '../exceptions/errorCodes';

const prisma = new PrismaClient();

export const verifyOTP = async (req: Request, res: Response, next: NextFunction) => {
  const { email, otp } = req.body;

  try {
    const user = await prisma.user.findUnique({
      where: { email },
      include: { otpVerifications: true },
    });

    if (!user) {
      return next(new BadRequestException('Utilisateur non trouvÃ©', ErrorCodes.USER_NOT_FOUND));
    }

    const userOtpVerification = user.otpVerifications.find((otpVerification) => otpVerification.otp === otp);

    if (!userOtpVerification || userOtpVerification.otpExpires < new Date()) {
      return next(new BadRequestException('OTP invalide ou expirÃ©', ErrorCodes.INVALID_OTP));
    }

    await prisma.user.update({
      where: { email },
      data: {
        otpVerifications: {
          deleteMany: {},
        },
      },
    });

    res.status(200).json({ message: 'OTP vÃ©rifiÃ© avec succÃ¨s' });
  } catch (error) {
    next(error);
  }
};
```

### 4. DÃ©finir les Routes

CrÃ©ez les routes pour l'inscription et la vÃ©rification OTP dans `src/routes/authRoutes.ts`.

```typescript
import { Router } from 'express';
import { registerUser, verifyOTP } from '../controllers/authController';

const router = Router();

router.post('/register', registerUser);
router.post('/verify-otp', verifyOTP);

export default router;
```

### 5. Ajouter les Routes Ã  l'Application

Mettez Ã  jour `src/app.ts` pour utiliser les routes d'authentification.

```typescript
import authRoutes from './routes/authRoutes';
import { errorHandler } from './middleware/errorHandler';

app.use('/api/auth', authRoutes);
app.use(errorHandler);
```

### 6. GÃ©rer les Erreurs

CrÃ©ez un fichier `src/exceptions/errorCodes.ts` pour les codes d'erreur.

```typescript
export enum ErrorCodes {
  USER_NOT_FOUND = 1001,
  USER_ALREADY_EXIST = 1002,
  INCORRECT_PASSWORD = 1003,
  INVALID_OTP = 1004,
}
```

CrÃ©ez un fichier `src/exceptions/root.ts` pour les classes d'exception.

```typescript
export class HttpException extends Error {
  message: string;
  errorCode: ErrorCodes;
  statusCode: number;
  errors: any;

  constructor(message: string, errorCode: ErrorCodes, statusCode: number, errors: any) {
    super(message);
    this.message = message;
    this.errorCode = errorCode;
    this.statusCode = statusCode;
    this.errors = errors;
  }
}

export class BadRequestException extends HttpException {
  constructor(message: string, errorCode: ErrorCodes) {
    super(message, errorCode, 400, null);
  }
}
```

### 7. Configurer Nodemailer

Configurez Nodemailer pour envoyer des emails d'OTP. Mettez Ã  jour votre fichier `.env` avec vos informations d'email.

### 8. Tester l'Application

Lancez l'application et testez les diffÃ©rentes routes.

```bash
npm run dev
```

Vous devriez maintenant pouvoir vous inscrire avec un email, recevoir un OTP par email, et vÃ©rifier cet OTP pour terminer l'inscription.

```javascript
```
```javascript
```



# resending otp






Pour implÃ©menter la fonctionnalitÃ© de renvoi d'OTP, nous allons ajouter un nouveau contrÃ´leur et une route spÃ©cifique pour cette fonctionnalitÃ©. Cette fonctionnalitÃ© permet Ã  l'utilisateur de demander un nouvel OTP s'il n'a pas reÃ§u ou a perdu le prÃ©cÃ©dent.

### Modifications nÃ©cessaires :

1. **CrÃ©er un contrÃ´leur pour le renvoi de l'OTP.**
2. **Ajouter une route pour le renvoi de l'OTP.**

### 1. CrÃ©er un contrÃ´leur pour le renvoi de l'OTP

Ajoutons la fonction `resendOTP` dans le fichier `authController.ts` :

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import { sendOTPEmail } from '../config/nodemailer';
import crypto from 'crypto';
import { BadRequestException } from '../exceptions/root';
import { ErrorCodes } from '../exceptions/errorCodes';

const prisma = new PrismaClient();

export const resendOTP = async (req: Request, res: Response, next: NextFunction) => {
  const { email } = req.body;

  try {
    const user = await prisma.user.findUnique({
      where: { email },
      include: { otpVerifications: true },
    });

    if (!user) {
      return next(new BadRequestException('Utilisateur non trouvÃ©', ErrorCodes.USER_NOT_FOUND));
    }

    const otp = crypto.randomBytes(3).toString('hex');
    const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    await prisma.userOtpVerification.create({
      data: {
        otp,
        otpExpires,
        userId: user.id,
      },
    });

    await sendOTPEmail(email, otp);

    res.status(200).json({ message: 'Nouvel OTP envoyÃ© avec succÃ¨s' });
  } catch (error) {
    next(error);
  }
};
```

### 2. Ajouter une route pour le renvoi de l'OTP

Ajoutons une nouvelle route dans `authRoutes.ts` pour permettre le renvoi de l'OTP :

```typescript
import { Router } from 'express';
import { registerUser, verifyOTP, resendOTP } from '../controllers/authController';

const router = Router();

router.post('/register', registerUser);
router.post('/verify-otp', verifyOTP);
router.post('/resend-otp', resendOTP);

export default router;
```

### 3. GÃ©rer les Erreurs

Assurez-vous que vos classes d'exception et codes d'erreur sont bien dÃ©finis. Voici un rappel :

#### errorCodes.ts

```typescript
export enum ErrorCodes {
  USER_NOT_FOUND = 1001,
  USER_ALREADY_EXIST = 1002,
  INCORRECT_PASSWORD = 1003,
  INVALID_OTP = 1004,
}
```

#### root.ts

```typescript
export class HttpException extends Error {
  message: string;
  errorCode: ErrorCodes;
  statusCode: number;
  errors: any;

  constructor(message: string, errorCode: ErrorCodes, statusCode: number, errors: any) {
    super(message);
    this.message = message;
    this.errorCode = errorCode;
    this.statusCode = statusCode;
    this.errors = errors;
  }
}

export class BadRequestException extends HttpException {
  constructor(message: string, errorCode: ErrorCodes) {
    super(message, errorCode, 400, null);
  }
}
```

### 4. Mettre Ã  jour Nodemailer

Si ce n'est pas encore fait, configurez Nodemailer pour envoyer des emails. Assurez-vous d'avoir vos informations d'email correctes dans le fichier `.env`.

Voici un exemple de configuration de Nodemailer dans `nodemailer.ts` :

```typescript
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransport({
  service: 'Gmail',
  auth: {
    user: process.env.EMAIL_USERNAME,
    pass: process.env.EMAIL_PASSWORD,
  },
});

export const sendOTPEmail = async (email: string, otp: string) => {
  const mailOptions = {
    from: process.env.EMAIL_USERNAME,
    to: email,
    subject: 'Your OTP Code',
    text: `Your OTP code is ${otp}`,
  };

  await transporter.sendMail(mailOptions);
};
```

### 5. Tester la fonctionnalitÃ© de renvoi d'OTP

1. Assurez-vous que votre application est en cours d'exÃ©cution :
    ```bash
    npm run dev
    ```

2. Effectuez une requÃªte POST Ã  `/api/auth/resend-otp` avec l'email de l'utilisateur dans le corps de la requÃªte.

3. VÃ©rifiez que l'utilisateur reÃ§oit un nouvel OTP par email.

En suivant ces Ã©tapes, vous devriez maintenant avoir une fonctionnalitÃ© complÃ¨te de renvoi d'OTP dans votre application.
```javascript
```
```javascript
```
```javascript
```


Pour crÃ©er un middleware qui vÃ©rifie si l'utilisateur connectÃ© est un administrateur, nous devons d'abord ajouter un champ `role` ou `isAdmin` dans notre modÃ¨le `User`. Ensuite, nous allons crÃ©er un middleware qui vÃ©rifie le rÃ´le de l'utilisateur Ã  partir du token JWT.

### 1. Ajouter un champ `role` Ã  votre modÃ¨le `User`

Ajoutons un champ `role` dans notre modÃ¨le `User` dans Prisma :

#### `schema.prisma`

```prisma
model User {
  id        String   @id @default(uuid())
  firstname String
  lastname  String
  email     String   @unique
  phoneNumber String @unique
  password  String
  role      String   @default("user") // Ajout du champ rÃ´le
  otpVerifications UserOtpVerification[]
}

model UserOtpVerification {
  id         String   @id @default(uuid())
  otp        String
  otpExpires DateTime
  userId     String
  user       User     @relation(fields: [userId], references: [id])
}
```

N'oubliez pas de migrer votre base de donnÃ©es aprÃ¨s avoir modifiÃ© le schÃ©ma :

```bash
npx prisma migrate dev --name add-role-to-user
```

### 2. CrÃ©er le middleware `isAdmin`

Ensuite, nous allons crÃ©er un middleware pour vÃ©rifier si l'utilisateur est un administrateur.

#### `middlewares/isAdmin.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const ACCESS_TOKEN_SECRET = process.env.ACCESS_TOKEN || 'youraccesstokensecret';

export const isAdmin = async (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers.authorization;

  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  const token = authHeader.split(' ')[1];

  try {
    const decoded = jwt.verify(token, ACCESS_TOKEN_SECRET) as { userId: string };

    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
    });

    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    if (user.role !== 'admin') {
      return res.status(403).json({ message: 'Forbidden: Admins only' });
    }

    (req as any).user = user; // Attacher l'utilisateur Ã  la requÃªte
    next();
  } catch (error) {
    return res.status(403).json({ message: 'Forbidden' });
  }
};
```

### 3. Utiliser le middleware dans vos routes

Utilisez ce middleware dans vos routes qui nÃ©cessitent une vÃ©rification d'administrateur.

#### `routes/adminRoutes.ts`

```typescript
import { Router } from 'express';
import { isAdmin } from '../middlewares/isAdmin';
import { someAdminController } from '../controllers/adminController';

const router = Router();

// ProtÃ©ger les routes avec le middleware isAdmin
router.get('/admin/dashboard', isAdmin, someAdminController);

export default router;
```

### 4. Exemple de contrÃ´leur admin

Voici un exemple de contrÃ´leur pour une route d'admin.

#### `controllers/adminController.ts`

```typescript
import { Request, Response } from 'express';

export const someAdminController = async (req: Request, res: Response) => {
  res.json({ message: 'Welcome to the admin dashboard', user: (req as any).user });
};
```

### 5. Mise Ã  jour de votre serveur

Assurez-vous d'ajouter le nouveau routeur admin Ã  votre serveur Express.

#### `server.ts`

```typescript
import express from 'express';
import bodyParser from 'body-parser';
import adminRoutes from './routes/adminRoutes';
import authRoutes from './routes/authRoutes';

const app = express();
const port = process.env.PORT || 9000;

app.use(bodyParser.json());

app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);

app.listen(port, () => {
  console.log(`Server is running on port http://localhost:${port}`);
});
```

En suivant ces Ã©tapes, vous avez maintenant un middleware `isAdmin` qui vÃ©rifie si l'utilisateur est un administrateur avant de lui permettre d'accÃ©der Ã  certaines routes protÃ©gÃ©es.
```javascript
```
```javascript
```



# Forgot password

1. L'utilisateur demande Ã  rÃ©initialiser son mot de passe en fournissant son email.
2. Un token de rÃ©initialisation est gÃ©nÃ©rÃ© et envoyÃ© Ã  l'email de l'utilisateur.
3. L'utilisateur utilise le token pour rÃ©initialiser son mot de passe.

### 1. Ajouter un modÃ¨le pour le token de rÃ©initialisation de mot de passe

Nous devons crÃ©er un modÃ¨le pour stocker les tokens de rÃ©initialisation de mot de passe dans Prisma.

#### `schema.prisma`

```prisma
model User {
  id              String   @id @default(uuid())
  firstname       String
  lastname        String
  email           String   @unique
  phoneNumber     String   @unique
  password        String
  role            String   @default("user")
  passwordResets  PasswordReset[]
  otpVerifications UserOtpVerification[]
}

model PasswordReset {
  id         String   @id @default(uuid())
  token      String
  expiresAt  DateTime
  userId     String
  user       User     @relation(fields: [userId], references: [id])
}
```

N'oubliez pas de migrer votre base de donnÃ©es aprÃ¨s avoir modifiÃ© le schÃ©ma :

```bash
npx prisma migrate dev --name add-password-reset
```

### 2. CrÃ©er les contrÃ´leurs pour le mot de passe oubliÃ©

Nous allons crÃ©er deux contrÃ´leurs : un pour demander la rÃ©initialisation du mot de passe et un pour rÃ©initialiser le mot de passe.

#### `controllers/authController.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import nodemailer from 'nodemailer';
import crypto from 'crypto';
import bcrypt from 'bcrypt';

const prisma = new PrismaClient();

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL,
    pass: process.env.EMAIL_PASSWORD,
  },
});

export const forgotPassword = async (req: Request, res: Response, next: NextFunction) => {
  const { email } = req.body;

  try {
    // 1. VÃ©rifier si l'utilisateur existe
    const user = await prisma.user.findUnique({ where: { email } });
    if (!user) {
      return res.status(404).json({ message: 'Utilisateur non trouvÃ©' });
    }

    // 2. GÃ©nÃ©rer un token de rÃ©initialisation de mot de passe
    const token = crypto.randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 3600000); // Token expire dans 1 heure

    // 3. Sauvegarder le token dans la base de donnÃ©es
    await prisma.passwordReset.create({
      data: {
        token,
        expiresAt,
        userId: user.id,
      },
    });

    // 4. Envoyer l'email de rÃ©initialisation
    const resetUrl = `http://localhost:3000/reset-password?token=${token}&id=${user.id}`;
    await transporter.sendMail({
      to: user.email,
      subject: 'RÃ©initialisation du mot de passe',
      html: `<p>Vous avez demandÃ© une rÃ©initialisation de mot de passe. Cliquez sur ce lien pour rÃ©initialiser votre mot de passe :</p><a href="${resetUrl}">RÃ©initialiser le mot de passe</a>`,
    });

    res.json({ message: 'Email de rÃ©initialisation envoyÃ©' });
  } catch (error) {
    next(error);
  }
};

export const resetPassword = async (req: Request, res: Response, next: NextFunction) => {
  const { token, id } = req.query;
  const { newPassword } = req.body;

  try {
    // 1. VÃ©rifier si le token est valide
    const passwordReset = await prisma.passwordReset.findFirst({
      where: {
        token: token as string,
        userId: id as string,
        expiresAt: { gte: new Date() },
      },
    });

    if (!passwordReset) {
      return res.status(400).json({ message: 'Token invalide ou expirÃ©' });
    }

    // 2. Hacher le nouveau mot de passe
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(newPassword, salt);

    // 3. Mettre Ã  jour le mot de passe de l'utilisateur
    await prisma.user.update({
      where: { id: passwordReset.userId },
      data: { password: hashedPassword },
    });

    // 4. Supprimer le token de rÃ©initialisation de la base de donnÃ©es
    await prisma.passwordReset.delete({
      where: { id: passwordReset.id },
    });

    res.json({ message: 'Mot de passe rÃ©initialisÃ© avec succÃ¨s' });
  } catch (error) {
    next(error);
  }
};
```

### 3. Ajouter les routes pour le mot de passe oubliÃ©

Nous allons crÃ©er des routes pour les deux contrÃ´leurs.

#### `routes/authRoutes.ts`

```typescript
import { Router } from 'express';
import { forgotPassword, resetPassword } from '../controllers/authController';

const router = Router();

router.post('/forgot-password', forgotPassword);
router.post('/reset-password', resetPassword);

export default router;
```

### 4. Mettre Ã  jour votre serveur

Assurez-vous d'ajouter le nouveau routeur d'authentification Ã  votre serveur Express.

#### `server.ts`

```typescript
import express from 'express';
import bodyParser from 'body-parser';
import authRoutes from './routes/authRoutes';
import adminRoutes from './routes/adminRoutes';
import { errorMiddleware } from './middlewares/errorMiddleware';

const app = express();
const port = process.env.PORT || 9000;

app.use(bodyParser.json());

app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);

// Middleware de gestion des erreurs
app.use(errorMiddleware);

app.listen(port, () => {
  console.log(`Server is running on port http://localhost:${port}`);
});
```

### 5. Middleware de gestion des erreurs

Assurez-vous d'avoir un middleware de gestion des erreurs dans votre application.

#### `middlewares/errorMiddleware.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import { HttpException } from '../exceptions/root';

export const errorMiddleware = (error: HttpException, req: Request, res: Response, next: NextFunction) => {
  const statusCode = error.statusCode || 500;
  res.status(statusCode).json({
    message: error.message,
    errorCode: error.errorCode,
    errors: error.errors,
  });
};
```

Avec ces Ã©tapes, vous devriez maintenant avoir une fonctionnalitÃ© de "mot de passe oubliÃ©" pleinement fonctionnelle dans votre application utilisant TypeScript, Prisma, MongoDB et Nodemailer.
```javascript
```
```javascript
```



otp phone

Pour l'envoi de SMS dans votre application Node.js avec TypeScript et Prisma, vous pouvez gÃ©rer la configuration de l'envoi de SMS de plusieurs maniÃ¨res. Voici une approche typique :

### 1. Configuration des variables d'environnement

Tout d'abord, utilisez des variables d'environnement pour stocker vos informations sensibles telles que les clÃ©s d'API SMS, les numÃ©ros de tÃ©lÃ©phone de l'expÃ©diteur, etc. Assurez-vous de ne jamais stocker ces informations directement dans votre code source pour des raisons de sÃ©curitÃ©.

CrÃ©ez un fichier `.env` Ã  la racine de votre projet et ajoutez-y vos variables :

```plaintext
TWILIO_ACCOUNT_SID=your_twilio_account_sid
TWILIO_AUTH_TOKEN=your_twilio_auth_token
TWILIO_PHONE_NUMBER=your_twilio_phone_number
```

### 2. Installation des dÃ©pendances

Utilisez `dotenv` pour charger les variables d'environnement Ã  partir de votre fichier `.env` :

```bash
npm install dotenv
```

Installez Ã©galement la bibliothÃ¨que `twilio` pour l'intÃ©gration avec Twilio (ou utilisez une autre bibliothÃ¨que de votre choix pour l'envoi de SMS) :

```bash
npm install twilio
```

### 3. Configuration du service d'envoi de SMS

CrÃ©ez un service ou un fichier dÃ©diÃ© pour gÃ©rer l'envoi de SMS. Voici un exemple de service utilisant Twilio :

```typescript
// sms.service.ts

import { Twilio } from 'twilio';
import dotenv from 'dotenv';

dotenv.config();

const twilioAccountSid = process.env.TWILIO_ACCOUNT_SID;
const twilioAuthToken = process.env.TWILIO_AUTH_TOKEN;
const twilioPhoneNumber = process.env.TWILIO_PHONE_NUMBER;

const twilioClient = twilio(twilioAccountSid, twilioAuthToken);

export async function sendSMS(phoneNumber: string, message: string): Promise<void> {
  try {
    await twilioClient.messages.create({
      body: message,
      from: twilioPhoneNumber,
      to: phoneNumber,
    });
    console.log(`SMS envoyÃ© Ã  ${phoneNumber}`);
  } catch (error) {
    console.error(`Erreur lors de l'envoi de SMS Ã  ${phoneNumber} :`, error);
    throw new Error('Erreur lors de l\'envoi de SMS.');
  }
}
```

### 4. Utilisation dans votre service OTP

IntÃ©grez ce service dans votre service OTP pour envoyer l'OTP par SMS :

```typescript
// otp.service.ts

import otpGenerator from 'otp-generator';
import { PrismaClient } from '@prisma/client';
import { sendSMS } from './sms.service';

const prisma = new PrismaClient();

export async function generateAndSendOTP(userId: number): Promise<void> {
  const otp = otpGenerator.generate(6, { upperCase: false, specialChars: false, alphabets: false });

  // Mettre Ã  jour l'utilisateur avec l'OTP gÃ©nÃ©rÃ©
  await prisma.user.update({
    where: { id: userId },
    data: { otp },
  });

  // Envoyer l'OTP par SMS
  const user = await prisma.user.findUnique({ where: { id: userId } });
  if (user?.phoneNumber) {
    const message = `Votre code OTP est : ${otp}. Ne le partagez avec personne.`;
    await sendSMS(user.phoneNumber, message);
  } else {
    throw new Error('L\'utilisateur n\'a pas de numÃ©ro de tÃ©lÃ©phone.');
  }
}
```

### Points Ã  considÃ©rer

- **SÃ©curitÃ© :** Assurez-vous de sÃ©curiser vos clÃ©s d'API et numÃ©ros de tÃ©lÃ©phone en les stockant dans des variables d'environnement.
- **Gestion des erreurs :** Capturez et gÃ©rez les erreurs de maniÃ¨re appropriÃ©e pour assurer la fiabilitÃ© de l'envoi de SMS.
- **Tests :** Testez l'envoi de SMS dans diffÃ©rents scÃ©narios pour vous assurer que tout fonctionne correctement.

Cette approche vous permet de sÃ©parer clairement la configuration et l'envoi de SMS dans votre application, rendant le code plus modulaire et plus facile Ã  maintenir. Assurez-vous d'adapter ce code Ã  vos besoins spÃ©cifiques et de suivre les meilleures pratiques pour l'intÃ©gration d'API SMS dans votre application.
```javascript
```
```javascript
```

Generer parrain link
Pour gÃ©nÃ©rer un lien de parrainage qui commence par "Ego" suivi de 7 caractÃ¨res alphanumÃ©riques alÃ©atoires, vous pouvez utiliser la mÃ©thode suivante en TypeScript avec Node.js. Voici comment vous pourriez le faire :

### Ã‰tapes pour gÃ©nÃ©rer le lien de parrainage

1. **Installation de la bibliothÃ¨que `randomstring` :**

   Utilisez la bibliothÃ¨que `randomstring` pour gÃ©nÃ©rer facilement des chaÃ®nes alÃ©atoires.

   ```bash
   npm install randomstring
   ```

2. **Code pour gÃ©nÃ©rer le lien de parrainage :**

   CrÃ©ez une fonction ou un service dÃ©diÃ© qui gÃ©nÃ¨re le lien de parrainage comme requis.

   ```typescript
   // referral.service.ts

   import randomstring from 'randomstring';

   export function generateReferralLink(): string {
       const prefix = 'Ego';
       const randomChars = randomstring.generate({ length: 7, charset: 'alphanumeric' });
       return `${prefix}${randomChars}`;
   }
   ```

   Cette fonction `generateReferralLink` utilise `randomstring` pour gÃ©nÃ©rer une chaÃ®ne alphanumÃ©rique alÃ©atoire de 7 caractÃ¨res. Elle prÃ©fixe ensuite cette chaÃ®ne avec "Ego" pour former le lien de parrainage complet.

3. **Utilisation dans votre application :**

   Vous pouvez maintenant utiliser cette fonction oÃ¹ vous avez besoin de gÃ©nÃ©rer des liens de parrainage. Par exemple, dans une route de crÃ©ation de compte ou dans un service de gestion des utilisateurs :

   ```typescript
   import { generateReferralLink } from './referral.service';

   // Exemple d'utilisation
   const referralLink = generateReferralLink();
   console.log('Referral Link:', referralLink);
   // Output: Referral Link: Ego1aB2cD
   ```

### Points Ã  considÃ©rer :

- **SÃ©curitÃ© :** Bien que ce lien ne soit pas un secret, il est gÃ©nÃ©rÃ© de maniÃ¨re alÃ©atoire et doit Ãªtre unique pour chaque utilisateur.
- **Validation :** Assurez-vous que le lien gÃ©nÃ©rÃ© respecte vos exigences en matiÃ¨re de format et de longueur.
- **Stockage :** Si vous avez besoin de stocker ces liens dans une base de donnÃ©es, assurez-vous d'avoir une colonne adÃ©quate pour les stocker en toute sÃ©curitÃ©.

Cette approche vous permet de gÃ©nÃ©rer facilement des liens de parrainage uniques conformes Ã  vos spÃ©cifications, en utilisant des outils simples et largement disponibles dans l'Ã©cosystÃ¨me Node.js. Assurez-vous de tester et d'intÃ©grer cette fonctionnalitÃ© selon les besoins spÃ©cifiques de votre application.
```javascript
```
```javascript
```
```javascript
```
```javascript
```











# SUSUSUSUSUPERADMIN


Configurer un super admin directement dans le code ou dans le fichier `.env` est une approche courante pour des raisons de sÃ©curitÃ© et de contrÃ´le. Cela garantit que le super admin n'a pas besoin de s'inscrire comme un utilisateur normal et que les informations sensibles telles que les identifiants peuvent Ãªtre sÃ©curisÃ©es correctement. Voici une bonne pratique pour gÃ©rer le super admin dans une application Node.js utilisant Prisma et JWT :

### 1. Configuration du Super Admin dans `.env`

Ajoutez les informations du super admin dans votre fichier `.env` :

```env
SUPER_ADMIN_EMAIL=superadmin@example.com
SUPER_ADMIN_PASSWORD=supersecurepassword
```

### 2. Initialisation du Super Admin dans le Code

Ajoutez une fonction qui s'exÃ©cute au dÃ©marrage de l'application pour crÃ©er le super admin s'il n'existe pas dÃ©jÃ . Cela peut Ãªtre fait dans le fichier principal de votre application (par exemple, `server.ts` ou `app.ts`).

```typescript
import prisma from './prisma'; // Assurez-vous que le chemin est correct
import bcrypt from 'bcrypt';
import dotenv from 'dotenv';

dotenv.config();

const initializeSuperAdmin = async () => {
    const { SUPER_ADMIN_EMAIL, SUPER_ADMIN_PASSWORD } = process.env;

    if (!SUPER_ADMIN_EMAIL || !SUPER_ADMIN_PASSWORD) {
        throw new Error('Super admin credentials are not set in the environment variables.');
    }

    // VÃ©rifiez si le super admin existe dÃ©jÃ 
    const existingAdmin = await prisma.user.findUnique({
        where: { email: SUPER_ADMIN_EMAIL }
    });

    if (!existingAdmin) {
        // CrÃ©ez le super admin
        const salt = await bcrypt.genSalt(10);
        const hashedPassword = await bcrypt.hash(SUPER_ADMIN_PASSWORD, salt);

        await prisma.user.create({
            data: {
                email: SUPER_ADMIN_EMAIL,
                password: hashedPassword,
                role: 'SUPER_ADMIN',
                isVerified: true,
                status: 'active'
            }
        });

        console.log('Super admin created');
    } else {
        console.log('Super admin already exists');
    }
};

// Appelez cette fonction au dÃ©marrage de l'application
initializeSuperAdmin().catch((err) => {
    console.error('Error initializing super admin:', err);
});
```

### 3. Middleware d'Authentification

CrÃ©ez un middleware pour vÃ©rifier les rÃ´les des utilisateurs, notamment pour protÃ©ger les routes rÃ©servÃ©es aux administrateurs :

```typescript
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import prisma from './prisma'; // Assurez-vous que le chemin est correct

export const authenticate = async (req: Request, res: Response, next: NextFunction) => {
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
        return res.status(401).json({ error: 'Access denied. No token provided.' });
    }

    try {
        const decoded = jwt.verify(token, 'your-secret-key') as { userId: string };
        const user = await prisma.user.findUnique({
            where: { id: decoded.userId }
        });

        if (!user) {
            return res.status(401).json({ error: 'Access denied. Invalid token.' });
        }

        req.user = user;
        next();
    } catch (err) {
        res.status(400).json({ error: 'Invalid token' });
    }
};

export const authorize = (role: string) => {
    return (req: Request, res: Response, next: NextFunction) => {
        if (req.user.role !== role) {
            return res.status(403).json({ error: 'Access denied. You do not have the required role.' });
        }
        next();
    };
};
```

### 4. ProtÃ©ger les Routes

Utilisez les middlewares `authenticate` et `authorize` pour protÃ©ger les routes rÃ©servÃ©es aux administrateurs :

```typescript
import express from 'express';
import { authenticate, authorize } from './middlewares/authMiddleware'; // Assurez-vous que le chemin est correct

const router = express.Router();

router.post('/admin-route', authenticate, authorize('ADMIN'), (req, res) => {
    // Route rÃ©servÃ©e aux administrateurs
    res.status(200).json({ message: 'Welcome, admin!' });
});

router.post('/super-admin-route', authenticate, authorize('SUPER_ADMIN'), (req, res) => {
    // Route rÃ©servÃ©e aux super administrateurs
    res.status(200).json({ message: 'Welcome, super admin!' });
});

export default router;
```

### Explications

1. **Configuration dans `.env`** : Les informations sensibles du super admin sont stockÃ©es dans le fichier `.env` pour une meilleure gestion de la configuration et la sÃ©curitÃ©.
   
2. **Initialisation du Super Admin** : Au dÃ©marrage de l'application, une fonction vÃ©rifie si le super admin existe dÃ©jÃ  dans la base de donnÃ©es. Si ce n'est pas le cas, elle le crÃ©e avec les informations fournies dans le fichier `.env`.

3. **Middleware d'Authentification et d'Autorisation** : Deux middlewares sont crÃ©Ã©s : un pour vÃ©rifier l'authentification et un autre pour vÃ©rifier les autorisations basÃ©es sur les rÃ´les.

4. **ProtÃ©ger les Routes** : Les routes rÃ©servÃ©es aux administrateurs et super administrateurs sont protÃ©gÃ©es Ã  l'aide des middlewares d'authentification et d'autorisation.

En suivant ces Ã©tapes, vous vous assurez que le super admin est correctement configurÃ© et sÃ©curisÃ©, sans nÃ©cessiter une crÃ©ation de compte traditionnelle.






```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
## ETAPE 4: ETABLIE LE MODEL USER

```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```
```javascript
```